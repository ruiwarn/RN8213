/*
 * @file: Dl645_Bkgrd.c
 * @brief: 处理后台任务，包括时间事件处理、低功耗管理（休眠/唤醒）等。
 * @author: [Auto-generated by Roo]
 * @date: 2025/04/11
 * @description: 此文件包含后台循环逻辑、定时任务触发、以及进入和退出低功耗模式的控制。
 *               注释已添加以解释寄存器操作和关键流程，目标是让新手易懂。
 */
#define  _DL645_BKGRD_GLOBALS
#include <App.h>


/*****************************************休眠处理子程序**********************************************/
/**
 * @brief 微秒级延时函数（依赖于系统时钟配置）。
 * @param i 延时次数（单位不精确，依赖fnDelay_1us实现）。
 * @return None
 * @note 仅在系统时钟不是特定配置时执行延时。
 */
void SystemDelayUs(u8 i)
{
	// 检查系统时钟控制寄存器OSC_CTRL1的特定位，如果不等于0x3，则执行延时
	// ((SYSCTL->OSC_CTRL1 >> 8) & 0x3) != 0x3 可能用于判断是否处于某种低功耗时钟模式
	if(((SYSCTL->OSC_CTRL1 >> 8) & 0x3) != 0x3)
	{
		for(; i > 0; i--) fnDelay_1us(); // 调用1微秒延时函数
	}
}

/**
 * @brief 低电压检测(LVD)检查函数。
 * @param None
 * @return u8 PowerFlag - 电源状态标志，值越小表示电压越高。
 * @note 通过多次采样MADC->LVD_STAT寄存器的CMP2IIF状态位来判断电源稳定性。
 */
u8 fnDl645Bkgrd_LVDCheck(void)
{
	u8	temp, i, j; // 临时变量和循环计数器
	u8	PowerFlag = 5; // 电源状态标志，初始值为5
	for(i = 0; i < 5; i++) // 进行5次大循环采样
	{
		temp = 50; // 每次大循环内部计数器
		for(j = 0; j < 50; j++) // 进行50次小循环采样
		{
			// 检查MADC LVD_STAT寄存器的bit 2 (0x04)，该位指示CMP2IIF状态
			if(!(MADC->LVD_STAT & 0x04)) temp++; // 如果CMP2IIF==0 低于阈值，计数增加
			else temp--; // 如果CMP2IIF==1 高于阈值，计数减少
			SystemDelayUs(10); // 短暂延时
			fnWDT_Restart(); // 重启看门狗
		}
		// 根据内部计数器的结果调整电源状态标志
		if(temp > 90) PowerFlag++; // 如果大部分时间电压低，增加标志
		if(temp < 10) PowerFlag--; // 如果大部分时间电压正常，减少标志
	}
	return PowerFlag; // 返回最终的电源状态标志
}

/**
 * @brief 配置GPIO和系统控制器进入休眠状态。
 * @param None
 * @return None
 * @note 此函数将大部分GPIO配置为输入下拉或特定状态以降低功耗，
 *       并配置系统控制器关闭不需要的时钟和模块，准备进入低功耗模式。
 */
void fnDl645Bkgrd_IOSetSleep(void)
{
	Dl645Bkgrd.PubData.Active = BKGRD_ACTIVE_POWDN; // 设置后台状态为掉电/休眠
   	
	// 配置GPIO端口A (P0, P1, P2, P3)
	GPIO->PMA = 0xFFFFFFFF; // 设置P0/P1为输入模式？(0xFFFFFFFF通常表示输入) 注释提供了部分引脚功能
	GPIO->PUA = 0x00000000; // 禁用P0/P1上拉/下拉？
	GPIO->PIMA = 0; // 配置P1输入模式？
	GPIO->PCA0 = 0x00000A20; // 配置P2功能选择，保留部分引脚功能（如UART）？
	GPIO->PCA1 = 0x00000000; // 配置P3功能选择
	GPIO->PIEA = 0xFFFFFCFF; // 配置端口A中断使能？(具体位含义需查手册)
	
	// 配置GPIO端口B (P4, P5, P6, P7)
	GPIO->PMB = 0xFFFFFFFF; // 设置P4/P5为输入模式？
	GPIO->PUB = 0x0; // 禁用P4/P5上拉/下拉？
	GPIO->PCB = 0x00000000; // 配置P6/P7功能选择
	GPIO->PIEB = 0xFFFFFFFF; // 配置端口B中断使能？

	// 配置GPIO端口C (P8, P9, P10, P11)
	GPIO->PMC = 0xFFFFFFFF; // 设置P8/P9为输入模式？
	GPIO->PUC = 0x00000000; // 禁用P8/P9上拉/下拉？
	GPIO->PCC = 0x00000000; // 配置P10/P11功能选择
	GPIO->PIEC = 0xFFFFFFFF; // 配置端口C中断使能？
		
	// 配置GPIO端口E (P12?)
	GPIO->PCE = 0x00000000; // 配置P12功能选择
	
	// 配置系统控制器进入低功耗模式
	SYSCTL->SYS_PS = 0x82; // 设置系统电源状态寄存器，准备进入低功耗模式 (0x82的具体含义需查手册)
	
    eepromStandby(); // 调用函数使外部EEPROM进入待机模式
	SYSCTL->SYS_PD = 0x00DF; // 设置系统掉电控制寄存器，关闭特定模块电源 (0xDF的位定义需查手册)
    SYSCTL->MOD0_EN = 0x0000; // 关闭模块0的所有时钟
    SYSCTL->MOD1_EN = 0x0C20; // 保留模块1的部分时钟？(0x0C20的位定义需查手册，可能保留RTC和KBI)
    SYSCTL->INTC_EN = 0x0000; // 关闭所有中断控制器？
    SYSCTL->SYS_PS = 0x00; // 恢复系统电源状态？(可能在进入WFI前需要恢复)
    
    // 配置NVIC中断控制器
    NVIC_DisableIRQ(UART0_IRQn); // 关闭UART0中断
	NVIC_DisableIRQ(UART1_IRQn); // 关闭UART1中断
	NVIC_DisableIRQ(UART3_IRQn); // 关闭UART3中断
	NVIC_DisableIRQ(TC0_IRQn);   // 关闭定时器TC0中断
	NVIC_EnableIRQ(KBI_IRQn);    // 使能键盘中断(KBI)，用于唤醒
	NVIC_DisableIRQ(ISO78161_IRQn); // 关闭ISO7816中断
	
	// 清除RTC中断标志并使能RTC中断
	RTC->IF = 0xFF; // 写1清除RTC所有中断标志位
	NVIC_EnableIRQ(RTC_IRQn); // 使能RTC中断，可能用于定时唤醒
}

/**
 * @brief 设置系统进入休眠模式的最终配置。
 * @param None
 * @return None
 * @note 调用IO配置函数，并配置KBI（键盘中断）作为唤醒源。
 */
void fnDl645Bkgrd_SleepSet(void)
{
	fnDl645Bkgrd_IOSetSleep(); // 配置IO和系统控制器
	SYSCTL->SYS_PS = 0x82; // 再次设置电源状态？确保进入低功耗
	SYSCTL->KBI_EN = 0x0103; // 使能KBI模块时钟，并配置唤醒源？(0x0103位定义需查手册)
    KBI->CTRL = 0x03; // 配置KBI控制寄存器，使能KBI？
	KBI->SEL = 0x03; // 配置KBI唤醒引脚选择？(选择KBI0和KBI1?)
    KBI->MASK = 0x03; // 配置KBI中断屏蔽，允许KBI0和KBI1中断？
}

/**
 * @brief 执行CPU的WFI（Wait For Interrupt）指令，使系统进入低功耗睡眠模式。
 * @param None
 * @return None
 * @note 在执行WFI前，会检查LVD状态，确保电压稳定。
 */
void fnDl645Bkgrd_Sleep(void)
{
    //if(Dl645Inactive.PubData.ActiveState==End_State) // 检查是否处于可以休眠的状态
    {
		if(!(MADC->LVD_STAT & 0x04)) // 再次检查LVD状态，确保电压正常
		{
			Dl645Inactive.PubData.InactiveStamp = 0; // 清除非活动时间戳
			__WFI(); // 执行WFI指令，CPU停止运行，等待中断唤醒
		}
    }
}

/**
 * @brief 进入休眠前的准备工作。
 * @param None
 * @return None
 * @note 清零前端相关的数据结构。
 */
void fnBeforeSleep(void)
{
    memset(&Dl645Front , 0 , sizeof(sDl645Front_TypeDef) ); // 清零前台数据
	memset(&Dl645FrontTmp , 0 , sizeof(sDl645FrontTmp_TypeDef) ); // 清零前台临时数据
}

/**
 * @brief 后台任务 - 每秒执行一次的函数（当前为空）。
 * @param None
 * @return None
 */
void fnDl645Bkgrd_Second_Exec(void)
{
	// 可在此添加每秒需要执行的后台任务
}

/**
 * @brief 后台任务 - 每分钟执行一次的函数（当前为空）。
 * @param None
 * @return None
 */
void fnDl645Bkgrd_Minute_Exec(void)
{
	// 可在此添加每分钟需要执行的后台任务
}

/**
 * @brief 后台任务 - 每小时执行一次的函数（当前为空）。
 * @param None
 * @return None
 */
void fnDl645Bkgrd_Hour_Exec(void)
{
	// 可在此添加每小时需要执行的后台任务
}

/**
 * @brief 后台任务 - 每天执行一次的函数（当前为空）。
 * @param None
 * @return None
 */
void fnDl645Bkgrd_Day_Exec(void)
{
	// 可在此添加每天需要执行的后台任务，如日冻结
}

/**
 * @brief 后台任务 - 每月执行一次的函数（当前为空）。
 * @param None
 * @return None
 */
void fnDl645Bkgrd_Month_Exec(void)
{
	// 可在此添加每月需要执行的后台任务，如月冻结
}

/**
 * @brief 后台任务模块初始化函数。
 * @param None
 * @return None
 * @note 清零后台数据结构，并用当前系统时间初始化后台时间记录。
 */
void fnDl645Bkgrd_Init(void)
{
	memset(&Dl645Bkgrd , 0 , sizeof(sDl645Bkgrd_TypeDef) ); // 清零后台数据结构
	// 从文件读取掉电时间？(被注释掉)
	//fnDl645File_Read(Dl645FileId_InterTmp , Dl645FileItemInfoOffAddr_InterTmp_Misc +  sizeof(sDF01) , &PowDnTime , sizeof(sDF01) );
	// 使用当前系统时间初始化后台私有时间记录
	Dl645Bkgrd.PriData.Second = SysClock.Second;
	Dl645Bkgrd.PriData.Minute = SysClock.Minute;
	Dl645Bkgrd.PriData.Hour = SysClock.Hour;
	Dl645Bkgrd.PriData.Day = SysClock.Day;
	Dl645Bkgrd.PriData.Month = SysClock.Month;
	
	Dl645Bkgrd.PubData.Second = SysClock.Second; // 初始化后台公共秒计数
}


/**
 * @brief 后台任务执行主函数。
 * @param None
 * @return None
 * @note 读取当前系统时间，与上次记录的时间比较，触发秒、分、时、日、月等周期性任务。
 */
void fnDl645Bkgrd_Exec(void)
{
    fnSysClock_Read(&SysClock); // 读取当前系统时间
	
	// 秒事件处理
	if(SysClock.Second != Dl645Bkgrd.PriData.Second) // 如果秒数发生变化
	{
	  fnDl645Bkgrd_Second_Exec(); // 执行秒任务
	  Dl645Bkgrd.PubData.fChange.FlagBit.Second = 1; // 设置秒变化标志
	  Dl645Bkgrd.PriData.Second = SysClock.Second; // 更新后台记录的秒数
	}
	
	// 如果系统不处于正常工作状态或有非活动标记，则不执行后续的分钟及以上任务
	if((Dl645Bkgrd.PubData.Active != BKGRD_ACTIVE_POWON) || (Dl645Inactive.PubData.InactiveStamp)) return;
			
	// 分钟事件处理
	if(SysClock.Minute != Dl645Bkgrd.PriData.Minute) // 如果分钟数发生变化
	{
		fnDl645Bkgrd_Minute_Exec(); // 执行分钟任务
		Dl645Bkgrd.PriData.Minute = SysClock.Minute; // 更新后台记录的分钟数
		Dl645Bkgrd.PubData.fChange.FlagBit.Minute = 1; // 设置分钟变化标志
	}
	
	// 小时事件处理
	if(SysClock.Hour != Dl645Bkgrd.PriData.Hour) // 如果小时数发生变化
	{
		fnDl645Bkgrd_Hour_Exec(); // 执行小时任务
		Dl645Bkgrd.PriData.Hour = SysClock.Hour; // 更新后台记录的小时数
		Dl645Bkgrd.PubData.fChange.FlagBit.Hour = 1; // 设置小时变化标志
	}
	
	// 天事件处理
	if(SysClock.Day != Dl645Bkgrd.PriData.Day) // 如果天数发生变化
	{
		fnDl645Bkgrd_Day_Exec(); // 执行天任务
		Dl645Bkgrd.PriData.Day = SysClock.Day; // 更新后台记录的天数
		Dl645Bkgrd.PubData.fChange.FlagBit.Day = 1; // 设置天变化标志
	}
	
	// 月事件处理
	if(SysClock.Month != Dl645Bkgrd.PriData.Month) // 如果月份发生变化
	{
		fnDl645Bkgrd_Month_Exec(); // 执行月任务
		Dl645Bkgrd.PriData.Month = SysClock.Month; // 更新后台记录的月份
		Dl645Bkgrd.PubData.fChange.FlagBit.Month = 1; // 设置月变化标志
	}
}

/**
 * @brief 处理系统非活动状态（掉电、唤醒、休眠管理）。
 * @param None
 * @return None
 * @note 这是系统低功耗管理的核心函数，处理电源恢复、掉电检测、进入休眠、按键唤醒等逻辑。
 */
void fnDl645Bkgrd_Inactive(void)
{
	u8	i; // 循环计数器
	u8	PowerFlag; // 电源状态标志
	
	// 如果当前不处于掉电/休眠状态
	if(Dl645Bkgrd.PubData.Active != BKGRD_ACTIVE_POWDN)
    {
		// 如果处于上电恢复过程中
    	if(Dl645Bkgrd.PubData.Active == BKGRD_ACTIVE_POWUP)
    	{
			// 等待上电稳定延时（例如500ms）
    		if(fnStamp_Through(Dl645Bkgrd.PubData.PownUpingDelay) > 500)
    		{
    			Dl645Bkgrd.PubData.Active = BKGRD_ACTIVE_POWON; // 延时结束，切换到正常工作状态
    		}

			// 在上电恢复过程中，如果检测到电压仍然很低，则立即重新进入低功耗
    		if(!(MADC->LVD_STAT & 0x04)) // 检查LVD状态位
    		{
				if(fnDl645Bkgrd_LVDCheck() > 8) // 再次确认电压确实很低
				{
					Dl645Bkgrd.PubData.Active = BKGRD_ACTIVE_POWDN; // 设置为掉电状态
					for(i = 0; i < 24; i++) {LCD->BUF[i] = 0x0;} // 清空LCD缓冲区
					Dl645Inactive.PubData.ActiveState = End_State; // 设置非活动状态为结束
					LCD->CTRL = 0x00; // 关闭LCD控制器
					for(i = 0; i < 60; i++) // 等待LCD关闭完成
					{
						if(!(LCD->STA & 0x40)) break; // 检查LCD状态寄存器的忙碌位
						fnRTCDrive_Delay(); // RTC驱动提供的延时
					}
					fnDl645Bkgrd_SleepSet(); // 配置系统进入休眠
					fnDl645SubClock_Init(); // 初始化子时钟（低功耗时钟）
				}
    		}
    	}
		// 如果有非活动标记（可能由中断或其他地方设置，用于检测意外掉电）
    	if(Dl645Inactive.PubData.InactiveStamp)
    	{
    		PowerFlag = fnDl645Bkgrd_LVDCheck(); // 检查电源状态
    		if(PowerFlag < 2) Dl645Inactive.PubData.InactiveStamp = 0; // 如果电压恢复，清除标记
    		else if(PowerFlag > 8) // 如果确认电压很低
    		{
				// 进入掉电处理流程
    			for(i = 0; i < 24; i++) {LCD->BUF[i] = 0x0;} // 清空LCD
    			Dl645Inactive.PubData.InactiveStamp = 0; // 清除标记
    			LCD->CTRL = 0x00; // 关闭LCD
    			fnBeforeSleep(); // 执行休眠前准备
    			Dl645Bkgrd.PubData.Active = BKGRD_ACTIVE_POWDN; // 设置为掉电状态
    			Dl645Inactive.PubData.ActiveState = End_State; // 设置非活动状态为结束
    			for(i = 0; i < 60; i++) // 等待LCD关闭
				{
					if(!(LCD->STA & 0x40)) break;
					fnRTCDrive_Delay();
				}
				fnDl645Bkgrd_SleepSet(); // 配置系统进入休眠
				fnDl645SubClock_Init(); // 初始化子时钟
    		}
    	}
    }
	
	// 如果系统处于掉电/休眠状态，则进入循环等待唤醒事件
    while(Dl645Bkgrd.PubData.Active == BKGRD_ACTIVE_POWDN)
    {
        fnWDT_Restart(); // 喂狗
        //if(Dl645Inactive.PubData.ActiveState == End_State) // 如果处于可以休眠的状态
    	{
    		fnDl645Bkgrd_Sleep(); // 执行WFI指令进入睡眠
    		fnWDT_Restart(); // 唤醒后喂狗
    	}
    	fnWDT_Restart(); // 喂狗
		
		// 处理唤醒后的状态（例如按键唤醒后显示一段时间）
    	if(Dl645Inactive.PubData.ActiveState == Running_State) // 如果是运行状态（被唤醒）
    	{
			// 如果唤醒后超过30秒无操作，则重新进入休眠
    		if((Dl645Inactive.PubData.ActiveStamp) && (Dl645Inactive.PubData.ActiveStamp > 30))
    		{
            	Dl645Inactive.InactiveFlag.SleepFlag = 0; // 清除休眠标志
    			LCD->CTRL = 0x0; // 关闭LCD
    			for(i = 0; i < 60; i++) // 等待LCD关闭
				{
					if(!(LCD->STA & 0x40)) break;
					fnRTCDrive_Delay();
				}
    			Dl645Inactive.PubData.ActiveState = End_State; // 设置状态为结束
    			Dl645Inactive.PubData.ActiveInit = 0; // 清除初始化标志
    			Dl645Inactive.PubData.ActiveStamp = 0; // 清除唤醒时间戳
    			fnDl645Bkgrd_IOSetSleep(); // 配置IO进入休眠
    		}
    	}
		
		// 处理按键唤醒事件
    	if(Dl645Inactive.InactiveFlag.fChange & 0x01)   // 检查按键按下标志
    	{
    		fnDl645Bkgrd_SleepWakeupDisp(); // 执行唤醒显示处理
    		Dl645Inactive.InactiveFlag.fChange &= 0xFE; // 清除按键标志
    	}
		// 处理秒进位事件（用于休眠时刷新显示）
    	if(Dl645Inactive.InactiveFlag.fChange & 0x02)   // 检查秒进位标志
    	{
    		if(Dl645Inactive.PubData.ActiveState == Running_State) fnDl645Bkgrd_SleepRefreshDisp(); // 如果处于唤醒运行状态，刷新显示
    		Dl645Inactive.InactiveFlag.fChange &= 0xFD; // 清除秒进位标志
    	}
		
		// 检查LVD状态，判断是否电源恢复
    	if(MADC->LVD_STAT & 0x04) // 如果LVD触发位被设置（表示电压可能已恢复）
		{
			for(i = 0; i < 100; i++) // 短暂延时去抖
			{
				__NOP();
				__NOP();
				__NOP();
			}
			fnWDT_Restart(); // 喂狗
			
			if(fnDl645Bkgrd_LVDCheck() < 2 ) // 再次检查确认电压已恢复
			{
				// 执行系统唤醒后的完整初始化流程
				Dl645Bkgrd.PubData.Active = BKGRD_ACTIVE_POWUP; // 设置状态为上电恢复
				Dl645Inactive.PubData.PowerErrFlag = 0x00; // 清除电源错误标志
				__disable_irq(); // 关闭中断
				fnTarget_Init(); // 目标板初始化
				fnSysClock_Read(&SysClock); // 读取时钟
				fnKey_Init(); // 初始化按键
				fnWDT_Restart(); // 喂狗
				fnDl645Bkgrd_Init(); // 初始化后台
				fnWDT_Restart(); // 喂狗
				fnScom_AllInit(); // 初始化通信
				fnWDT_Restart(); // 喂狗
				fnDl645Disp_Init(); // 初始化显示
				fnDl645Front_Init(); // 初始化前台
				fnWDT_Restart(); // 喂狗
				__enable_irq(); // 使能中断
				// 初始化完成后，循环将退出while，进入正常工作流程
			}
		}
    }
	return; // 正常工作状态或处理完唤醒事件后返回
}

/**
 * @brief 处理按键唤醒后的显示逻辑。
 * @param None
 * @return None
 * @note 初始化相关时钟、模块，配置GPIO用于LCD，并根据模式（自动/按键）显示内容。
 */
void fnDl645Bkgrd_SleepWakeupDisp(void)
{
	u8	temp1; // 临时变量
	fnDl645RCClock_Init(); // 初始化RC时钟？（可能用于唤醒后的临时时钟源）
	eepromWakeup(); // 唤醒外部EEPROM
	SYSCTL->SYS_PS = 0x82; // 设置电源状态
	SYSCTL->MOD0_EN |= 0x0004; // 使能模块0的某个时钟（bit 2，可能是GPIO或LCD？）
	
	if(Dl645Inactive.PubData.ActiveState == End_State) // 如果是从完全休眠状态唤醒
	{
		if(Dl645Inactive.PubData.ActiveInit == 0x0) // 如果是首次唤醒初始化
		{
            Dl645Inactive.PubData.ActiveInit = 0x1; // 设置初始化标志
			SYSCTL->SYS_PS = 0x82; // 设置电源状态
			SYSCTL->MOD1_EN |= 0x0660; // 使能模块1的特定时钟（LCD, Timer等？）
			SYSCTL->SYS_PS = 0x00; // 恢复电源状态
			// 配置LCD相关的GPIO引脚功能
			GPIO->PMB &= 0xFE0FFFFF; // 配置P5引脚？
			GPIO->PMC &= 0xFFFFFF00; // 配置P8引脚？
			GPIO->PCB = 0xF01F0000; // 配置P6/P7引脚？
			GPIO->PCC = 0x000000FF; // 配置P10引脚？
			GPIO->PCE = 0x0000000F; // 配置P12引脚？
            fnDl645Disp_Init(); // 初始化LCD显示模块
		}
		Dl645Inactive.PubData.ActiveState = Running_State; // 设置状态为唤醒运行中
		Dl645Session.Mode = DISPLAYAUTO; // 默认进入自动显示模式
	}
	else // 如果之前已唤醒，再次按键则进入按键显示模式
	{
		Dl645Session.Mode = DISPLAYKEY;
	}
	
	// 根据显示模式加载并显示内容
	if(Dl645Session.Mode == DISPLAYAUTO) // 自动显示模式
	{
		fnWDT_Restart(); // 喂狗
		fnDl645File_Read(Dl645FileId_GeneralPara , Dl645FileItemInfoOffAddr_GeneralPara_DispPara + 5, Dl645Session.Item , 5); // 读取第一个循显项目
		fnDl645Disp_RefreshDispData(); // 准备显示数据
		fnLcd_RefreshLcdBuf(); // 刷新LCD缓冲区
		fnWDT_Restart(); // 喂狗
		fnDl645File_Read(Dl645FileId_GeneralPara , Dl645FileItemInfoOffAddr_GeneralPara_DispPara + 1 , (u8 *)&temp1, 1);  // 读取循显时间间隔
		temp1 = fnBcdToHex_u8(temp1); // BCD转HEX
		if(temp1 == 0) temp1 = 5; // 默认5秒
		Dl645Session.Stamp = temp1; // 设置显示时间戳
	}
	else // 按键显示模式
	{
		fnDl645File_Read(Dl645FileId_GeneralPara , Dl645FileItemInfoOffAddr_GeneralPara_DispPara + 4 , (u8 *)&temp1, 1); // 读取按键显示屏数
		temp1 = fnBcdToHex_u8(temp1); // BCD转HEX
		if(++Dl645Session.KeySeriaNo > temp1) // 按键序号循环
		{
			Dl645Session.KeySeriaNo = 1;
		}
		// 读取对应的按键显示项目
		fnDl645File_Read(Dl645FileId_GeneralPara , Dl645FileItemInfoOffAddr_GeneralPara_DispPara + 5 + 5 * DL645_MAX_CYCDISP + (Dl645Session.KeySeriaNo - 1) * 5 , Dl645Session.Item, 5);
		if(Dl645Session.Item[4] == InvalidItem) // 如果项目无效，回到第一个按键项目
		{
			fnDl645File_Read(Dl645FileId_GeneralPara , Dl645FileItemInfoOffAddr_GeneralPara_DispPara + 5 + 5 * DL645_MAX_CYCDISP  , Dl645Session.Item, 5);
			Dl645Session.KeySeriaNo = 0;
		}
		fnDl645Disp_RefreshDispData(); // 准备显示数据
		fnLcd_RefreshLcdBuf(); // 刷新LCD缓冲区
	}
	Dl645Inactive.PubData.ActiveStamp = 0; // 重置唤醒活动时间戳
	SYSCTL->SYS_PS = 0x00; // 恢复电源状态
	eepromStandby(); // EEPROM进入待机
	// 如果电源错误标志未设置，初始化子时钟？
	if((Dl645Inactive.PubData.PowerErrFlag != 0x5A) && (Dl645Inactive.PubData.PowerErrFlag != 0x5B)) fnDl645SubClock_Init();
}

/**
 * @brief 在休眠状态下定时刷新LCD显示（例如显示时间和日期）。
 * @param None
 * @return None
 * @note 此函数在秒进位事件中被调用，用于更新LCD内容，并在自动显示模式下处理显示项切换和超时返回休眠。
 */
void fnDl645Bkgrd_SleepRefreshDisp(void)
{
	u8	temp1; // 临时变量
	u8	i; // 循环计数器
	
	// 判断是否需要刷新时间/日期显示（每两秒或特定显示项）
	if(((SysClock.Second) % 2) || ((Dl645Session.Item[3] == 4) && (Dl645Session.Item[1] == 1) && (Dl645Session.Item[2] == 0) && ((Dl645Session.Item[0] == 1) || (Dl645Session.Item[0] == 2))))
	{
		fnLcd_ClrScr(); // 清屏
		fnWDT_Restart(); // 喂狗
		if(Dl645Session.Item[0] == 1) // 如果当前显示项是日期
		{
			// 显示日期 YY-MM-DD
			fnLcd_SetDigit(7, (SysClock.Day & 0xF0) >> 4);
			fnLcd_SetDigit(8, SysClock.Day & 0x0F);
			fnLcd_SetDigit(5, (SysClock.Month & 0xF0) >> 4);
			fnLcd_SetDigit(6, SysClock.Month & 0x0F);
			fnLcd_SetDigit(3, (SysClock.Year & 0xF0) >> 4);
			fnLcd_SetDigit(4, SysClock.Year & 0x0F);
			fnLcd_SetDigit(1, (0x20 & 0xF0) >> 4); // 显示年份前缀 "20"
			fnLcd_SetDigit(2, 0x20 & 0x0F);
			fnLcd_SetSegment(SEG_QsegDp4, 1); // 显示分隔符 "-"
			fnLcd_SetSegment(SEG_QsegDp6, 1); // 显示分隔符 "-"
		}
		else // 如果当前显示项是时间
		{
			// 显示时间 HH:MM:SS
		    fnLcd_SetSegment(SEG_dangqian, 1); // 显示 "当前" 标志？
			fnLcd_SetSegment(SEG_TIME, 1); // 显示 "时间" 标志？
			fnLcd_SetSegment(SEG_JIAN, 1); // 显示 "尖" 标志？（可能表示费率）
			fnLcd_SetDigit(7, (SysClock.Second & 0xF0) >> 4);
			fnLcd_SetDigit(8, SysClock.Second & 0x0F);
		    fnLcd_SetDigit(5, (SysClock.Minute & 0xF0) >> 4);
		    fnLcd_SetDigit(6, SysClock.Minute & 0x0F);
		    fnLcd_SetDigit(3, (SysClock.Hour & 0xF0) >> 4);
		    fnLcd_SetDigit(4, SysClock.Hour & 0x0F);
			fnLcd_SetSegment(SEG_QsegDp9, 1); // 显示分隔符 ":"
			fnLcd_SetSegment(SEG_QsegDp4, 1); // 显示分隔符 ":"
			fnLcd_SetSegment(SEG_QsegDp8, 1); // 可能用于闪烁？
			fnLcd_SetSegment(SEG_QsegDp6, 1); // 可能用于闪烁？
		}
		fnLcd_RefreshLcdBuf(); // 刷新LCD缓冲区
		fnWDT_Restart(); // 喂狗
	}
	
	// 处理自动显示模式下的逻辑
	if(Dl645Session.Mode == DISPLAYAUTO)
	{
		// 如果唤醒活动时间超过了当前项的显示时间
		if(Dl645Inactive.PubData.ActiveStamp > Dl645Session.Stamp)
		{
			Dl645Inactive.PubData.ActiveStamp = 0; // 重置活动时间戳
			fnDl645RCClock_Init(); // 初始化RC时钟
			eepromWakeup(); // 唤醒EEPROM
			SYSCTL->SYS_PS = 0x82; // 设置电源状态
			SYSCTL->MOD0_EN |= 0x0004; // 使能模块时钟
			Dl645Session.AutoSerialNo++; // 自动显示序号增加
			
			fnDl645File_Read(Dl645FileId_GeneralPara , Dl645FileItemInfoOffAddr_GeneralPara_DispPara , (u8 *)&temp1, 1); // 读取自动循显总屏数
			temp1 = fnBcdToHex_u8(temp1); // BCD转HEX
			
			// 如果显示完所有项目，则返回休眠
			if(Dl645Session.AutoSerialNo >= temp1)
			{
				eepromStandby(); // EEPROM待机
				fnWDT_Restart(); // 喂狗
				SYSCTL->SYS_PS = 0x00; // 恢复电源状态
				fnDl645SubClock_Init(); // 初始化子时钟
				fnWDT_Restart(); // 喂狗
				Dl645Inactive.InactiveFlag.SleepFlag = 0; // 清除休眠标志
    			LCD->CTRL = 0x0; // 关闭LCD控制器
    			for(i = 0; i < 60; i++) // 等待LCD关闭
				{
					if(!(LCD->STA & 0x40)) break; // 检查LCD状态
					fnRTCDrive_Delay(); // 延时
				}
    			Dl645Inactive.PubData.ActiveState = End_State; // 设置状态为结束
    			Dl645Inactive.PubData.ActiveInit = 0; // 清除初始化标志
    			Dl645Inactive.PubData.ActiveStamp = 0; // 清除活动时间戳
    			fnWDT_Restart(); // 喂狗
    			fnDl645Bkgrd_IOSetSleep(); // 配置IO进入休眠
			}
			else // 否则，切换到下一个显示项目
			{
				fnWDT_Restart(); // 喂狗
				// 读取下一个循显项目
				fnDl645File_Read(Dl645FileId_GeneralPara , Dl645FileItemInfoOffAddr_GeneralPara_DispPara + 5 + 5 * Dl645Session.AutoSerialNo, Dl645Session.Item , 5);
				if(Dl645Session.Item[4] == InvalidItem) // 如果项目无效，回到第一个项目
				{
					fnDl645File_Read(Dl645FileId_GeneralPara , Dl645FileItemInfoOffAddr_GeneralPara_DispPara + 5 , Dl645Session.Item, 5);
				}
				fnWDT_Restart(); // 喂狗
				fnDl645Disp_RefreshDispData(); // 准备显示数据
				fnLcd_RefreshLcdBuf(); // 刷新LCD
				eepromStandby(); // EEPROM待机
				fnWDT_Restart(); // 喂狗
				SYSCTL->SYS_PS = 0x00; // 恢复电源状态
				fnDl645SubClock_Init(); // 初始化子时钟
			}
		}
	}
}










