/*
 * @file: Scom.c
 * @brief: 实现串行通信端口管理和协议处理分发。
 * @author: [Auto-generated by Roo]
 * @date: 2025/04/11
 * @description: 管理多个串行端口（RS485, IR, ZBCOM），处理数据包的接收、发送状态机，
 *               并根据接收到的数据帧调用相应的协议处理函数（目前主要是DL/T645-2007）。
 */
#define  _SCOM_GLOBALS // 用于全局变量实例化
#include <App.h> // 包含应用层主头文件
 
//---------------- 全局常量定义 --------------------

/**
 * @brief USART波特率定义数组。
 * 将波特率枚举值映射到具体的波特率常量 (USART_BPS_XXX 定义在驱动层)。
 * 用于 fnScomPk_Init 函数根据 NewBps 标志位选择正确的波特率配置。
 */
const u8 eUsartBps_Def[8] = {
	USART_BPS_300, USART_BPS_600, USART_BPS_1200, USART_BPS_2400, USART_BPS_4800,
	USART_BPS_7200, USART_BPS_9600, USART_BPS_19200
};
	
/**
 * @brief 控制通信端口的发送使能/禁止 (通常用于RS485的DIR引脚)。
 * @param ComPort 通信端口号 (eScomPort_TypeDef)。
 * @param EnOrDis 功能状态 (ENABLE 或 DISABLE)。
 * @return None
 * @note 当前函数体为空，具体实现依赖于硬件连接和底层GPIO驱动。
 */
void fnScomPk_TxEnDis(u8 ComPort , FunctionalState EnOrDis)
{
	// 添加控制RS485收发切换引脚的GPIO操作代码
}

/**
 * @brief 初始化指定的通信端口。
 * @param ComPort 通信端口号 (eScomPort_TypeDef)。
 * @return None
 * @note - 检查端口号有效性。
 *       - 初始化该端口的通信包结构体 (ComPack)，清空缓冲区和标志位。
 *       - 根据 NewBps 成员的值选择合适的波特率。
 *       - 调用底层UART初始化函数 fnUsart_Init 配置串口参数。
 *       - 对RS485端口，默认禁用发送。
 */
void fnScomPk_Init(u8 ComPort)
{
	u8 USART_BPS; // 存储选择的波特率常量
	if(ComPort >= SCOM_PORT_MAX) return; // 检查端口号是否有效
	
	// 初始化通信包结构体
	ComPack[ComPort].EFlag = SCOMPK_EFLAG_IDLE; // 设置初始状态为空闲
 	ComPack[ComPort].RxLen = 0; // 清零接收长度
 	ComPack[ComPort].TxLen = 0; // 清零发送长度
  	ComPack[ComPort].TimeOutStamp = 0; // 清零超时时间戳
 	memset(&ComPack[ComPort].RxBuf[0] , 0 , MAX_COMPACK_SIZE); // 清空接收缓冲区
	memset(&ComPack[ComPort].TxBuf[0] , 0 , MAX_COMPACK_SIZE); // 清空发送缓冲区
	
	// 根据 NewBps 标志位选择波特率 (NewBps 是一个位掩码)
	if(ComPack[ComPort].NewBps & 0x01) USART_BPS = eUsartBps_Def[0]; // 300 bps
  	else if(ComPack[ComPort].NewBps & 0x02) USART_BPS = eUsartBps_Def[1]; // 600 bps
  	else if(ComPack[ComPort].NewBps & 0x04) USART_BPS = eUsartBps_Def[2]; // 1200 bps
  	else if(ComPack[ComPort].NewBps & 0x08) USART_BPS = eUsartBps_Def[3]; // 2400 bps
  	else if(ComPack[ComPort].NewBps & 0x10) USART_BPS = eUsartBps_Def[4]; // 4800 bps
  	else if(ComPack[ComPort].NewBps & 0x20) USART_BPS = eUsartBps_Def[6]; // 9600 bps (注意索引是6)
  	else if(ComPack[ComPort].NewBps & 0x40) USART_BPS = eUsartBps_Def[7]; // 19200 bps
  	else USART_BPS = eUsartBps_Def[3]; // 默认 2400 bps
	
	// 根据端口号调用底层UART初始化函数
	switch(ComPort)
	{
	case SCOM_PORT_RS485A: // RS485端口
		// 初始化USART，配置波特率、偶校验、8位数据、1位停止位
		fnUsart_Init(ComPort , USART_BPS | USART_EVEN_PARITY | USART_8BIT_DAT | USART_1STOP_SBIT );
		fnScomPk_TxEnDis(ComPort , DISABLE); // 默认禁用发送 (接收模式)
		break;
	case SCOM_PORT_IR: // 红外端口
		// 固定使用1200bps，偶校验，8位数据，1位停止位
		fnUsart_Init(ComPort , USART_BPS_1200 | USART_EVEN_PARITY | USART_8BIT_DAT | USART_1STOP_SBIT );
		break;
	case SCOM_PORT_ZBCOM: // 载波通信端口
		// 固定使用2400bps，偶校验，8位数据，1位停止位
		fnUsart_Init(ComPort , USART_BPS_2400 | USART_EVEN_PARITY | USART_8BIT_DAT | USART_1STOP_SBIT );
		break;
	default: // 无效端口号
		return;
	}
}

/**
 * @brief 更改通信端口的波特率。
 * @param ComPort 通信端口号 (eScomPort_TypeDef)。
 * @return None
 * @note - 检查波特率变更标志 fBps 是否设置。
 *       - 如果设置，调用 fnScomPk_Init 重新初始化端口以应用新的波特率。
 *       - 清除波特率变更相关标志和时间戳。
 */
void fnScomPk_ChangeBps(u8 ComPort)
{
	if(ComPack[ComPort].fBps == 0) return; // 如果没有设置波特率变更标志，直接返回
	fnScomPk_Init(ComPort); // 重新初始化端口以应用 NewBps 中设置的波特率
	ComPack[ComPort].NewBpsStamp = 0; // 清除新波特率时间戳
	ComPack[ComPort].fBps = 0; // 清除波特率变更标志
}

/**
 * @brief 初始化所有通信端口。
 * @param None
 * @return None
 * @note - 从文件系统读取RS485端口的波特率配置。
 *       - 调用 fnScomPk_Init 分别初始化RS485、IR和ZBCOM端口。
 */
void fnScom_AllInit(void)
{
	// 从通用参数文件中读取RS485A的波特率特征字 (偏移地址+2)
	fnDl645File_Read(Dl645FileId_GeneralPara , Dl645FileItemInfoOffAddr_GeneralPara_ComPara + 2 , &ComPack[SCOM_PORT_RS485A].NewBps , 1 );
	fnScomPk_Init(SCOM_PORT_RS485A); // 初始化RS485A端口
	fnScomPk_Init(SCOM_PORT_IR);     // 初始化红外端口
	fnScomPk_Init(SCOM_PORT_ZBCOM);  // 初始化载波端口
}

/**
 * @brief 通信端口主执行函数（状态机）。
 * @param ComPort 通信端口号 (eScomPort_TypeDef)。
 * @return None
 * @note - 管理数据包的接收和发送流程。
 *       - 处理接收超时。
 *       - 在接收完成后调用协议处理函数 fnPt_Exec。
 *       - 处理发送流程，包括添加前导码、控制收发切换、启用/禁用中断。
 *       - 处理发送超时。
 *       - 在空闲状态下检查并执行波特率变更。
 */
void fnScomPk_Exec(u8 ComPort)
{
	u16	Len = 0; // 存储响应帧长度

	if(ComPort >= SCOM_PORT_MAX) return; // 检查端口号有效性
	
	// 如果系统不处于正常工作状态，不执行通信处理
	if((Dl645Bkgrd.PubData.Active != BKGRD_ACTIVE_POWON) || (Dl645Inactive.PubData.InactiveStamp)) return;
			
	// 接收状态超时处理 (如果在接收过程中停留时间过长)
	if((ComPack[ComPort].EFlag == SCOMPK_EFLAG_RXHEAD1) || // 正在接收第一个帧头
	   (ComPack[ComPort].EFlag == SCOMPK_EFLAG_RXHEAD2) || // 正在接收第二个帧头
	   (ComPack[ComPort].EFlag == SCOMPK_EFLAG_RXDATALEN) || // 正在接收长度字节
	   (ComPack[ComPort].EFlag == SCOMPK_EFLAG_RXEND))     // 正在接收数据或校验
	{
		// 如果距离上次更新时间戳超过500ms，则认为超时
		if(fnStamp_Through(ComPack[ComPort].TimeOutStamp) > 500 )
			ComPack[ComPort].EFlag = SCOMPK_EFLAG_INIT; // 重置状态机到初始状态
		else
			return; // 未超时，继续等待
	}
	
	// 接收完成状态处理
	if(ComPack[ComPort].EFlag == SCOMPK_EFLAG_RXFINISH)
	{
		Len = fnPt_Exec(ComPort); // 调用协议处理函数，获取响应帧长度
		if(Len) // 如果需要发送响应
		{
			ComPack[ComPort].TxLen = Len; // 设置发送长度
			ComPack[ComPort].EFlag = SCOMPK_EFLAG_TXSTART; // 设置状态为准备发送
			Dl645Bkgrd.PubData.CommStatus |= F_Comm1Event; // 设置通信活动标志
		}
		else // 如果不需要响应
		{
			ComPack[ComPort].EFlag = SCOMPK_EFLAG_INIT; // 重置状态机
		}
	}
	
	// 准备发送状态处理
	if(ComPack[ComPort].EFlag == SCOMPK_EFLAG_TXSTART)
	{
		// 等待至少20ms的接收-发送转换延时
		if(fnStamp_Through(ComPack[ComPort].TimeOutStamp) < 20) return;
		
		ComPack[ComPort].EFlag = SCOMPK_EFLAG_TXBUSY; // 设置状态为发送中
		// 在发送缓冲区前部填充DL/T645协议要求的前导码
		memset(&ComPack[ComPort].TxBuf[0] , DL645B_LEADERCODE , DL645B_LEADERCODE_LEN);
		ComPack[ComPort].TxLen += DL645B_LEADERCODE_LEN; // 更新总发送长度
		fnScomPk_TxEnDis(ComPort , ENABLE);	// 使能发送 (例如，切换RS485 DIR引脚)
		ComPack[ComPort].pTx = &ComPack[ComPort].TxBuf[0]; // 设置发送指针指向缓冲区起始
		USART_ITConfig(ComPort , USART_IT_RX, DISABLE); // 禁止接收中断
		USART_ITConfig(ComPort , USART_IT_TX, ENABLE);  // 使能发送中断 (发送将在中断中进行)
		ComPack[ComPort].TimeOutStamp = SysStamp ? SysStamp : (SysStamp - 1); // 记录发送开始时间戳
	}
	
	// 发送中状态处理 (超时检查)
	if(ComPack[ComPort].EFlag == SCOMPK_EFLAG_TXBUSY)
	{
		// 如果发送时间超过3秒 (OS_TICKS_PER_SEC 需要定义为每秒的节拍数)
		if(fnStamp_Through(ComPack[ComPort].TimeOutStamp) > (OS_TICKS_PER_SEC * 3) )
			ComPack[ComPort].EFlag = SCOMPK_EFLAG_TXFINISH; // 认为发送超时/完成
		else
			return; // 未超时，继续发送 (在中断中)
	}
	
	// 发送完成状态处理
	if(ComPack[ComPort].EFlag == SCOMPK_EFLAG_TXFINISH)
	{
		ComPack[ComPort].EFlag = SCOMPK_EFLAG_INIT; // 重置状态机
		fnScomPk_TxEnDis(ComPort , DISABLE); // 禁止发送 (例如，切换RS485 DIR引脚到接收)
		USART_ITConfig(ComPort , USART_IT_TX, DISABLE); // 禁止发送中断
		// 注意：此处未重新使能接收中断，可能在 fnScomPk_Init 中完成
	}
	
	// 初始状态处理 (端口恢复/波特率变更)
	if(ComPack[ComPort].EFlag == SCOMPK_EFLAG_INIT)
	{
		fnScomPk_ChangeBps(ComPort); // 检查是否需要改变波特率
		fnScomPk_Init(ComPort); // 重新初始化端口 (会使能接收中断)
	}
}

//---------------- 协议处理相关函数 --------------------

/**
 * @brief 在接收缓冲区中查找有效的协议帧。
 * @param Src 指向接收缓冲区的指针。
 * @param Len 接收数据的长度。
 * @param PtType 指向存储检测到的协议类型的变量的指针。
 * @return u8* 如果找到有效帧，返回指向帧起始位置的指针；否则返回NULL。
 * @note - 遍历接收缓冲区。
 *       - 对每个可能的起始位置调用 fnDl645B_FrameCheck 进行DL/T645-2007帧检查。
 *       - 如果找到有效帧头，检查接收长度是否足够包含整个帧。
 *       - 设置 PtType 并返回帧指针。
 */
u8 *fnPt_Check(u8 *Src , u16 Len , ePtType_TypeDef *PtType)
{
	u16 i; // 循环计数器
	u8 	err; // 存储帧检查结果
	
	for(i = 0 ; i < Len ; i++ , Src++) // 遍历接收缓冲区
	{
		// 调用DL/T645-2007帧检查函数
		err = fnDl645B_FrameCheck( (sFrmDl645B_TypeDef *) Src);
		if(err == SUCCESS) // 如果找到有效的DL645帧头和地址
		{
			// 检查接收的数据长度是否足够包含该帧 (帧头+地址+控制码+长度+数据域+校验+帧尾 = 12 + 数据域长度)
			if(Len < (i + (*(sFrmDl645B_TypeDef *)Src).Len + 12) ) // i是当前偏移
			{
				*PtType = PTTYEP_NONE; // 数据不完整
				// 注意：这里应该返回NULL，让状态机继续接收，而不是直接判断为无协议
				return NULL; // 返回NULL表示帧不完整或未找到
			}
			else // 数据长度足够
			{
				*PtType = PTTYEP_DL645B; // 设置协议类型为DL645B
				return Src; // 返回有效帧的起始指针
			}
		}
	}
	
	// 遍历完成仍未找到有效帧
	*PtType = PTTYEP_NONE; // 设置协议类型为无
	return NULL; // 返回NULL
}

/**
 * @brief 执行协议处理。
 * @param ComPort 通信端口号。
 * @return u16 响应帧的长度，0表示无响应。
 * @note - 调用 fnPt_Check 查找并识别接收缓冲区中的协议帧。
 *       - 如果找到有效帧，根据协议类型调用相应的协议处理函数 (目前仅支持DL/T645B)。
 */
u16 fnPt_Exec(u8 ComPort)
{
	u8 				*sFrame; // 指向有效帧的指针
	ePtType_TypeDef	PtType;  // 检测到的协议类型
	u16				Len = 0; // 响应帧长度
//	u8				TxAdd; // 未使用的变量

	// 检查接收缓冲区中的协议帧
	sFrame = fnPt_Check(&ComPack[ComPort].RxBuf[0] , ComPack[ComPort].RxLen , &PtType);
	
	if(sFrame != NULL) // 如果找到有效帧
	{
		if(PtType == PTTYEP_DL645B) // 如果是DL/T645-2007协议
		{
			// 调用DL/T645-2007协议处理函数
			Len = fnDl645B_Exec(ComPort , (sFrmDl645B_TypeDef *)sFrame);
		}
		// else if (PtType == PTTYEP_XXX) { ... } // 可在此扩展支持其他协议
		else
		{
			Len = 0; // 不支持的协议类型，无响应
		}
	}
	else // 未找到有效帧
	{
		Len = 0; // 无响应
	}
	return Len; // 返回响应帧长度
}










