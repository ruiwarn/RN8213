/*
 * @file: Dl645_Front.c
 * @brief: 负责电能计量前端处理，包括初始化、数据采集和计算。
 * @author: [Auto-generated by Roo]
 * @date: 2025/04/11
 * @description: 此文件管理电能计量的核心逻辑，包括寄存器初始化、数据读取和校准处理。
 *               注释已添加以解释寄存器操作，目标是让新手易懂。
 */

#define  _DL645_FRONT_GLOBALS
#include <App.h>

// 函数功能：测量时钟电池电压和温度
// 入口参数：无
// 出口参数：无
void fnFront_ClockBatCalculate(void)
{
	u32 ClockBat;  // 存储ADC读取的原始数据，类型为32位无符号整数
	u8	i;          // 循环计数器，类型为8位无符号整数
	
	for(i = 0; i < 255; i++)  // 循环等待ADC通道就位，最多255次迭代
	{
		if(!(MADC->AD_STAT & 0x02)) break;  // 检查MADC AD_STAT 寄存器的bit 1（通道忙碌标志），如果清零则退出循环
		__NOP();  // 执行空操作指令，用于引入延时，防止CPU过载
		__NOP();
		__NOP();
		__NOP();
	}
	MADC->AD_CTRL = 0x01;  // 设置MADC AD_CTRL 寄存器，选择通道2（vbat），并设置0.5倍增益。根据RN8213手册，AD_CTRL控制ADC通道和增益。
	MADC->AD_START = 0x01;  // 设置MADC AD_START 寄存器，启动ADC转换。
	SystemDelay(1);  // 调用SystemDelay函数，延时1ms，确保ADC转换完成。
	for(i = 0; i < 150; i++)  // 循环等待转换完成标志，最多150次迭代
	{
		if(MADC->AD_STAT & 0x01) break;  // 检查MADC AD_STAT 寄存器的bit 0（转换完成标志），如果置位则退出循环
		__NOP();  // 空操作延时
		__NOP();
		__NOP();
		__NOP();
	}
	ClockBat = MADC->AD_DATA;  // 读取MADC AD_DATA 寄存器，获取ADC转换结果。
	ClockBat = (ClockBat * 508) / 1024;  // 转换电压值：将ADC数据转换为实际电压。508和1024是比例因子，基于ADC参考电压和增益计算，参考手册ADC转换公式。
	Dl645Front.PubData.ClockBat = fnHexToBcd_u16((u16)ClockBat);  // 将计算后的电压值转换为BCD格式存储在Dl645Front结构中。ClockBat单位：毫伏（mV）？

	// 当前温度值测量，使用RTC温度传感器
	ClockBat = RTC->TEMP;  // 读取RTC TEMP 寄存器，获取温度数据。RTC TEMP寄存器存储温度值，参考RN8213手册RTC模块。
	ClockBat &= 0x3FF;  // 掩码操作，取低10位（bit 9:0），这是温度数据的有效部分，bit 9是符号位。
	if(ClockBat & 0x200)  // 检查bit 9，如果置位表示温度为负
	{
		ClockBat = 0x3FF - ClockBat;  // 计算温度绝对值（补码转换）
		Dl645Front.PubData.Temperature = fnHexToBcd_u16((u16)((ClockBat * 10) / 4)) | 0x8000;  // 转换为BCD格式，并设置最高位表示负温度。公式基于手册，可能为摄氏度 * 10。
	}
	else
	{
		Dl645Front.PubData.Temperature = fnHexToBcd_u16((u16)((ClockBat * 10) / 4));  // 转换为BCD格式。温度单位：0.1°C？
	}
}

/*****************************************************************************
** Function name:	fnEMU_Init(void)
**
** Descriptions:	计量EMU初始化函数，写入校表寄存器
** parameters:		None
** Returned value:	None
******************************************************************************/
void fnEMU_Init(void)
{
	SYSCTL->SYS_PS = 0x82;  // 设置系统电源状态寄存器SYS_PS，切换到特定模式以便配置ADC。参考SYS_PS寄存器定义，可能用于时钟源切换。
	SYSCTL->ADC_CTRL = 0x0003;  // 配置ADC控制寄存器ADC_CTRL，将I1通道设置为16倍增益。增益设置影响ADC测量范围和精度。
	SYSCTL->SYS_PS = 0x00;  // 恢复系统电源状态，结束配置模式。
	EMU->SPCMD = 0xe5;  // 设置SPCMD寄存器，启用写入保护解除。SPCMD用于控制计量寄存器的写保护，0xe5是使能码，参考RN8213手册。
	EMU->HFConst 	= 	Dl645FirmPara.HFConst;  // 设置高频常数寄存器HFConst，用于定义计量脉冲常数，影响电能计算精度。
	EMU->IAGAIN 	= 	Dl645FirmPara.IAGain;  // 设置A通道电流增益寄存器IAGAIN，用于电流测量校准。
	EMU->IBGAIN 	= 	Dl645FirmPara.IBGain;  // 设置B通道电流增益寄存器IBGAIN，用于B通道电流测量校准。
	EMU->UGAIN 		= 	Dl645FirmPara.UGain;  // 设置电压增益寄存器UGAIN，用于电压测量校准。
	EMU->GPQA		= 	Dl645FirmPara.GPQA;  // 设置A通道功率相位校准寄存器GPQA，用于修正功率相位误差。
	EMU->GPQB		= 	Dl645FirmPara.GPQB;  // 设置B通道功率相位校准寄存器GPQB，用于修正B通道功率相位误差。
	EMU->PhsA 		= 	Dl645FirmPara.PhsA;  // 设置A相相位寄存器PhsA，用于相位补偿。
	EMU->PhsB 		= 	Dl645FirmPara.PhsB;  // 设置B相相位寄存器PhsB，用于B相相位补偿。
	EMU->APOSA 		= 	Dl645FirmPara.APOSA;  // 设置A通道小信号偏移校准寄存器APOSA，用于小电流范围校正。
	EMU->APOSB 		= 	Dl645FirmPara.APOSB;  // 设置B通道小信号偏移校准寄存器APOSB，用于B通道小电流范围校正。
	EMU->PStart 	= 	Dl645FirmPara.PStart;  // 设置有功功率启动阈值寄存器PStart，定义最小计量功率阈值。
	EMU->QStart 	= 	Dl645FirmPara.QStart;  // 设置无功功率启动阈值寄存器QStart，定义最小无功功率计量阈值。
	EMU->IARMSOS 	= 	Dl645FirmPara.IARMSOS;  // 设置A通道RMS偏移校准寄存器IARMSOS，用于修正A通道电流RMS偏移。
	EMU->IBRMSOS 	= 	Dl645FirmPara.IBRMSOS;  // 设置B通道RMS偏移校准寄存器IBRMSOS，用于修正B通道电流RMS偏移。
	EMU->SPCMD 		= 	0xdc;  // 设置SPCMD寄存器，恢复写保护。0xdc是保护码，防止误改寄存器值。
}

/*****************************************************************************
** Function name:	fnDl645Front_Init(void)
**
** Descriptions:	计量模块初始化函数，将计量用到的RAM数据进行初始化
** parameters:		None
** Returned value:	None
******************************************************************************/
void fnDl645Front_Init(void)
{
	u8 	i, j;  // 循环计数器 i 和 j
	u32 ChkSum;  // 存储校验和变量
	
	memset(&Dl645FrontTmp, 0, sizeof(sDl645FrontTmp_TypeDef));  // 清零临时数据结构，确保所有字段从零开始
	memset(&Dl645Front, 0, sizeof(sDl645Front_TypeDef));  // 清零前台数据结构，确保起始状态干净
	
	fnDl645File_Read(Dl645FileId_FirmPara, 0, (u8 *)&Dl645FirmPara, sizeof(sDl645FirmParaFile_TypeDef));  // 从文件系统读取固件参数，包括所有校表数据
	Dl645FrontTmp.ChkSum1 = Dl645FirmPara.ChkSum;  // 保存固件参数的校验和，用于验证写入正确性
	
	// 写入校表寄存器，并检查校验。最多尝试5次以确保成功。
	for(i = 0; i < 5; i++)  // 外层循环，最多5次尝试
	{
        fnEMU_Init();  // 调用EMU初始化函数，写入寄存器
        SystemDelay(10);  // 延时10ms，等待硬件响应
        for(j = 0; j < 5; j++)  // 内层循环，等待EMU状态稳定，最多5次
        {
        	if(!(EMU->EMUStatus & 0x01000000)) break;  // 检查EMUStatus寄存器bit 24，如果清零表示稳定
        	SystemDelay(10);  // 每10ms检查一次
        }
        fnWDT_Restart();  // 重启看门狗定时器，防止系统复位
        ChkSum = EMU->EMUStatus & 0x00FFFFFF;  // 读取EMU状态寄存器低24位作为当前校验和
    	if(Dl645FrontTmp.ChkSum1 == ChkSum) break;  // 如果校验和匹配，写入成功，退出循环
    }
    
    RtcWriteDota(Dl645FirmPara.RTCDota0);  // 写入RTC的数字校准寄存器，RTCDota0是从文件系统读取的校准值
    fnWDT_Restart();  // 重启看门狗
    fnFront_ClockBatCalculate();  // 调用函数测量并更新电池电压和温度
    fnWDT_Restart();  // 重启看门狗
}

// 函数功能：从计量芯片读取数据并进行计算
// 入口参数：无
// 出口参数：无
void fnDl645Front_Exec(void)
{
    u8 i;  // 循环计数器
    u32 TempU, TempI, TempIn;  // 临时变量：TempU用于功率因数，TempI用于A相电流，TempIn用于B相或零线电流
    u32 TempStatus;  // 临时变量存储EMU状态寄存器值
    u16 TempAngle;  // 临时变量存储角度数据
    
    // 如果后台不处于正常工作状态（非BKGRD_ACTIVE_POWON）或有非活动标记，直接返回，优化性能
    if((Dl645Bkgrd.PubData.Active != BKGRD_ACTIVE_POWON) || (Dl645Inactive.PubData.InactiveStamp)) return;
    
    // 与系统500ms计时器同步，每500ms执行一次。如果SysStamp500未超过500，退出
    if(SysStamp500 > 500)
    {
        Dl645Bkgrd.PubData.fChange.FlagBit.t500ms = 1;  // 设置后台500ms标志位，通知其他模块
        SysStamp500 -= 500;  // 重置500ms计时器
    }
    if(!Dl645Bkgrd.PubData.fChange.FlagBit.t500ms) return;  // 如果500ms标志未设置，返回
    
    // 时钟电池电压和温度测量，保持数据更新
    fnFront_ClockBatCalculate();
    
    // 如果需要重置计量模块（FRONT_FLAG_RN8209RST标志位），则重新初始化并返回
    if(Dl645Front.PriData.Flag & FRONT_FLAG_RN8209RST)
    {
        fnDl645Front_Init();  // 重新初始化计量模块
        Dl645Front.PriData.Flag &= ~FRONT_FLAG_RN8209RST;  // 清除重置标志
        return;
    }
    
    // 读取RTC校准参数，并确保一致
    fnDl645File_Read(Dl645FileId_FirmPara, Dl645FileItemInfoOffAddr_FirmPara_RTCDota0, (u8 *)&Dl645FirmPara.RTCDota0, 2);
    if(RtcReadDota() != Dl645FirmPara.RTCDota0) RtcWriteDota(Dl645FirmPara.RTCDota0);  // 如果不匹配，写入校准值
    
    // 读取EMU状态寄存器，检查忙碌标志和校验
    TempStatus = EMU->EMUStatus;  // EMUStatus寄存器包含计量状态信息，包括忙碌标志、方向等
    if(!(TempStatus & 0x01000000))  // 如果bit 24未设置，表示EMU忙碌或错误状态
    {
        if(Dl645FrontTmp.ChkSum1 == (TempStatus & 0x00FFFFFF))  // 比较校验和
        {
            Dl645FrontTmp.ChkErrCnt = 0;  // 校验成功，重置错误计数
        }
        else
        {
            Dl645FrontTmp.ChkErrCnt++;  // 校验失败，错误计数增加
            if(Dl645FrontTmp.ChkErrCnt > 3)  // 如果连续三次错误
            {
                Dl645Front.PriData.Flag |= FRONT_FLAG_RN8209RST;  // 设置重置标志
                Dl645FrontTmp.ChkErrCnt = 0;  // 重置错误计数
            }
            return;  // 返回，等待下次调用
        }
    }
    
    // 判断功率方向
    if(TempStatus & 0x02000000)  // 检查bit 25，设置表示功率反向
    {
        Dl645Front.PubData.PDirect = INVERSION;  // 设置功率方向为反向
    }
    else
    {
        Dl645Front.PubData.PDirect = POSITIVE;  // 设置功率方向为正向
    }
    
    // 读取电压、电流到临时缓冲区，如果数据为负则清零（处理符号位）
    Dl645FrontTmp.UI[0] = EMU->IARMS;  // 读取A相RMS电流
    Dl645FrontTmp.UI[1] = EMU->IBRMS;  // 读取B相RMS电流
    Dl645FrontTmp.UI[2] = EMU->URMS;   // 读取RMS电压
    for(i = 0; i < 3; i++)  // 循环处理三个UI值
    {
        if(Dl645FrontTmp.UI[i] & 0x00800000) Dl645FrontTmp.UI[i] = 0;  // 如果bit 23设置（表示负数），清零
    }
    
    // 读取频率
    Dl645FrontTmp.Frequency = EMU->Ufreq;  // 读取电压频率寄存器
    
    // 读取功率到临时缓冲区，如果数据为负则取反加一（转换为正数）
    Dl645FrontTmp.Pw[0] = EMU->PowerPA;  // 读取A相有功功率
    Dl645FrontTmp.Pw[1] = EMU->PowerPB;  // 读取B相有功功率
    for(i = 0; i < 2; i++)  // 循环处理两个功率值
    {
        if(Dl645FrontTmp.Pw[i] & 0x80000000) Dl645FrontTmp.Pw[i] = (~Dl645FrontTmp.Pw[i]) + 1;  // 如果bit 31设置（负数），取反加一
    }
    
    // 计算功率值，使用功率系数校准
    Dl645Front.PubData.Pw = fnDFConver_Hex32ToDF09((s32)((Dl645FrontTmp.Pw[0]) / (Dl645FirmPara.KPrms)));  // KPrms是功率校准系数
    
    // 计算电流和电压值，使用相应系数校准
    Dl645Front.PubData.U = 0x7FFF & (fnDFConver_Bcd16To16((s16)(Dl645FrontTmp.UI[2] / (10 * (Dl645FirmPara.KUrms)))));  // 电压校准，使用KUrms系数
    TempI = (s32)(Dl645FrontTmp.UI[0] / (Dl645FirmPara.KIArms));  // A相电流计算，使用KIArms系数
    TempIn = (s32)(Dl645FrontTmp.UI[1] / (Dl645FirmPara.KIBrms));  // B相或零线电流计算，使用KIBrms系数
    Dl645Front.PubData.Ia = fnDFConver_Bcd32To32(TempI);  // 转换为BCD32格式
    Dl645Front.PubData.In = fnDFConver_Bcd32To32(TempIn);  // 转换为BCD32格式
    
    // 根据通道选择计算功率有效值和功率因数
    if(Dl645Front.PubData.Chnsel)  // Chnsel标志决定使用A或B通道数据
    {
        Dl645Front.PubData.Pw = fnDFConver_Hex32ToDF09((s32)((Dl645FrontTmp.Pw[1]) / (Dl645FirmPara.KPrms)));  // B通道功率
        TempU = EMU->PFB;  // B通道功率因数原始数据
        TempAngle = EMU->ANGLEB;  // B通道角度数据
    }
    else
    {
        Dl645Front.PubData.Pw = fnDFConver_Hex32ToDF09((s32)((Dl645FrontTmp.Pw[0]) / (Dl645FirmPara.KPrms)));  // A通道功率
        TempU = EMU->PFA;  // A通道功率因数原始数据
        TempAngle = EMU->ANGLEA;  // A通道角度数据
    }
    
    // 计算功率因数和角度
    TempU &= 0x00FFFFFF;  // 掩码取低24位有效数据
    if(TempU & 0x00800000) TempU = ((~TempU) & 0x00FFFFFF) + 1;  // 如果负数，转换为正数
    Dl645Front.PubData.Pf = fnHexToBcd_u16((u16)((float)TempU / 8388.608));  // 转换为BCD格式，8388.608是转换因子
    Dl645Front.PubData.Angle = fnHexToBcd_u16(TempAngle * 3600 / 32768);  // 角度计算并转换为BCD格式
    
    // 功率小于阈值时清零
    if(((Dl645Front.PubData.Pw.Dat2 & 0x7F) == 0) && (Dl645Front.PubData.Pw.Dat1 == 0) && (Dl645Front.PubData.Pw.Dat0 < 0x30))  // 检查功率是否小于0.0030
    {
        Dl645Front.PubData.Pw.Dat0 = 0;  // 清零Dat0
        Dl645Front.PubData.Pw.Dat1 = 0;  // 清零Dat1
        Dl645Front.PubData.Pw.Dat2 = 0;  // 清零Dat2
    }
    
    // 电流小于启动电流时清零
    if((Dl645Front.PubData.Ia) < 0x00000150) {Dl645Front.PubData.Ia = 0; Dl645Front.PubData.Pf = 0x0999;}  // 阈值0x00000150可能对应0.0015A，清零Ia并设置Pf为最大值0.999
    if((Dl645Front.PubData.In) < 0x00000150) Dl645Front.PubData.In = 0;  // 类似处理In
    
    // 计算电压频率
    Dl645Front.PubData.Frequency = fnHexToBcd_u16((u16)(((u32)184320000) / ((u32)4 * Dl645FrontTmp.Frequency)));  // 频率计算，转换为BCD格式
    
    // 读取电能脉冲并累加
    Dl645FrontTmp.Pulse = EMU->EnergyP;  // 读取EnergyP寄存器，获取累积脉冲数
    if(Dl645FrontTmp.Pulse > 100) Dl645FrontTmp.Pulse = 0;  // 容错，如果脉冲数过大，清零
    Dl645FrontTmp.Pulse_Eg += Dl645FrontTmp.Pulse;  // 累加到总脉冲计数器
    #if  DL645SOFT_DEBUG
    Dl645FrontTmp.Pulse_Eg += 1;  // 调试模式下额外增加脉冲，模拟计数
    #endif
}
 
 


