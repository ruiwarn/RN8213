/*
 * @file: Dl645_ICEsam.c
 * @brief: 实现与IC卡或ESAM模块的通信和处理逻辑。
 * @author: [Auto-generated by Roo]
 * @date: 2025/04/11
 * @description: 使用ISO7816接口与卡片进行通信，包括卡片检测、复位、ATR获取和后续处理流程。
 *               注释已添加以解释寄存器操作和关键流程，目标是让新手易懂。
 */
#define  _DL645_ICEsam_GLOBALS
#include <App.h>

/**
 * @brief 检查IC卡是否存在并获取ATR (Answer To Reset)。
 * @param None
 * @return ErrorStatus SUCCESS表示成功获取ATR，ERROR表示失败。
 * @note 此函数通过ISO7816接口执行卡片复位序列，并尝试以不同波特率与卡片同步，最终获取ATR信息。
 */
ErrorStatus fnICEsam_CheckCard(void)
{
	ErrorStatus result; // 存储函数调用结果
	u8 tempData, i;   // 临时数据和循环计数器
	u32	temp0;        // 临时存储波特率计算值
	
	// 配置ISO7816控制器1 (CTRL1)
	// 具体位含义需参考RN8213手册，0x70000201可能包含：
	// - 使能ISO7816接口
	// - 配置时钟、复位信号极性
	// - 设置通信模式（T=0/T=1）等
	ISO7816->CTRL1 = 0x70000201;
	
  	ISO7816->STA1 = 0x3F; // 清除ISO7816状态寄存器1 (STA1) 中的所有状态标志位 (写1清除)
	
	// 设置初始波特率分频值 (BDDIV1)
	// F/D = 768 => 波特率 ≈ 时钟频率 / 768。假设初始尝试较低波特率，如2400bps。
	// 0x230000: 高位的0x23可能代表分频系数F，低位的0x00可能代表分频系数D或其他配置。
	ISO7816->BDDIV1 = 0X230000;
	
	// 发送复位信号或特定字节(0x00)到卡片，启动复位流程
  	if(fnCardSendByte(CARD , 0x00) == ERROR) return ERROR; // 调用底层发送函数
	
	// 切换到另一个波特率配置，可能用于接收ATR的初始字符TS
	// F/D = 307 => 波特率 ≈ 时钟频率 / 307。假设尝试较高波特率，如6000bps？
	// 0x213300: 具体含义需查手册。
	ISO7816->BDDIV1 = 0X213300;
	
	// 发送特定字节(0x16)？用途不明确，可能是协议特定要求或同步字节。
	if(fnCardSendByte(CARD , 0x16) == ERROR) return ERROR;
	
	// 读取卡片返回的数据（可能是TS或后续字节）
	tempData = ISO7816->DATA1; // 从数据寄存器DATA1读取
	
	// 重新配置ISO7816控制器1？(与第一次配置相同，可能冗余或有特殊用途)
    ISO7816->CTRL1 = 0x70000201;
	
    ISO7816->STA0 = 0x3F; // 清除状态寄存器0 (STA0) 的所有标志位
	
	// 接收卡片返回的后续字节 (Procedure Byte?)
	result = fnCardGetByte( CARD, &tempData ); // 调用底层接收函数
	// 检查接收是否成功以及接收到的字节是否为预期值(0x16)
	if(( result != SUCCESS ) || (tempData != 0x16)) return ERROR;
	
	// 再次接收一个字节 (可能是TCK校验字节或TC1长度字节?)
	if(fnCardGetByte( CARD, &tempData ) == ERROR) return ERROR;
	
	// 根据接收到的字节计算新的波特率分频值
	// temp0 = (u32)(307 * 372) / (u32)(tempData << 1); // 基于ATR中的TA1字节计算F/D值？(307和372是ISO7816标准中的默认值)
	// temp0 = (temp0 << 8) & 0x002FFF00; // 格式化计算结果以匹配BDDIV1寄存器格式
	// ISO7816->BDDIV1 = (temp0 | 0x00200000); // 设置新的波特率分频值，0x00200000可能是使能位或其他配置
    
    // --- 新增注释：基于上下文推断波特率计算和设置 ---
    // 根据ATR中的TC1字节(tempData)计算时钟速率转换因子F和波特率调整因子D
    // F=372, D=tempData (TC1的值)。计算得到新的ETU持续时间对应的分频值。
    // 这里的计算方式 (307 * 372) / (tempData << 1) 比较特殊，需核对ISO7816标准和RN8213手册。
    // 假设最终结果用于设置BDDIV1寄存器以匹配卡片速率。
    temp0 = (u32)(307 * 372) / (u32)(tempData << 1); // F=307?, D=372? 还是 F=372, D=tempData? 需确认
    temp0 = (temp0 << 8) & 0x002FFF00; // 调整格式以匹配BDDIV1的高位部分？
    ISO7816->BDDIV1 = (temp0 | 0x00200000); // 写入新的波特率分频值，0x200000可能是使能位或固定配置

	// 延时等待波特率切换稳定
	for(i = 0; i < 200; i++)
	{
		fnDelay_1us();
		fnDelay_1us();
	}
			
	// 再次发送特定字节(0x16)？
	if(fnCardSendByte(CARD , 0x16) == ERROR) return ERROR;
	
	// 再次接收并检查响应字节
	result = fnCardGetByte( CARD, &tempData );
	if(( result != SUCCESS ) || (tempData != 0x16)) return ERROR;
	
	// 循环接收ATR的剩余字节 (最多13个？)
	for(i = 0; i < 13; i++) // 循环次数可能需要根据实际ATR长度调整
	{
		result = fnCardGetByte( CARD, &tempData ); // 接收ATR字节 (T0, TAi, TBi, TCi, TDi ...)
		if( result != SUCCESS )
			return ERROR; // 接收失败
		ICEsamComm.Ic_Comm_RxBuf[i] = tempData; // 存储接收到的字节
	}
	return SUCCESS; // ATR接收成功
}

/**
 * @brief IC卡/ESAM处理主流程。
 * @param None
 * @return None
 * @note 仅在特定表类型(METERTYPE == 1)下执行。检查系统状态和电压，
 *       调用卡检查函数，处理结果并更新LCD显示，最后关闭卡接口。
 */
void fnICEsam_Card_Proc( void )
{
#if(METERTYPE == 1) // 条件编译，仅当METERTYPE为1时编译此段代码
	eICEsam_ErrInfo_TypeDef Ic_Err_Flag = CARD_PROC_OK; // 初始化错误标志为OK
	
	// 检查系统是否处于正常工作状态
	if((Dl645Bkgrd.PubData.Active != BKGRD_ACTIVE_POWON) || (Dl645Inactive.PubData.InactiveStamp)) return;
	// 检查是否有卡插入事件标志 (I7816ComExt未在此文件定义)
	if( !I7816ComExt.EFlag) return;
	// 再次检查后台状态
	if(Dl645Bkgrd.PubData.Active != BKGRD_ACTIVE_POWON) return;
	
	// 检查电压是否过低 (0x1750 转为十进制为 5968，单位mV？表示5.968V？阈值需确认)
	if(Dl645Front.PubData.U < 0x1750)
	{
		Ic_Err_Flag = IC_PowerDn_ERR; // 设置电压过低错误
		// 此处缺少错误处理流程，应该类似下方CheckCard失败的处理
	}
	else // 电压正常
	{
		PinWrite_LCDLight(1); // 点亮LCD背光
		Dl645Session.BkLightFlag = 0x5A; // 设置背光标志
		Dl645Session.BkLightStamp = 194; // 启动背光计时器
		CardFoutOpen(); // 打开卡座电源或使能信号？(函数未在此文件定义)
		
		// 调用卡检查和ATR获取函数
		if(fnICEsam_CheckCard() == ERROR)
		{
			// 卡检查失败处理
			ISO7816->BDDIV1 = 0X230000; // 恢复到较低波特率
	  		fnCardSendByte(CARD , 0x00); // 发送0x00，可能用于停止卡时钟或去激活
			I7816ComExt.EFlag = 0; // 清除卡插入标志
			// 更新LCD显示错误信息
			fnLcd_SetSegment(SEG_DuKa, 1); // "读卡"
			fnLcd_SetSegment(SEG_Fail, 1); // "失败"
			fnLcd_RefreshLcdBuf(); // 刷新LCD
			// 设置显示时间戳
			Dl645Session.Stamp = 3;
			Dl645Session.CardDispStamp = 3;
			Dl645Session.DisplyErrFlag = 0; // 清除显示刷新标志？
			
			// 可能尝试禁用ISO7816接口？(0x80000000位含义需查手册)
			ISO7816->CTRL1 |= 0x80000000;
			
			// 准备错误信息返回给上层？
			memset(&ICEsamComm.Ic_Comm_RxBuf[9] , 0x00 , 7); // 清空部分缓冲区
			ICEsamComm.Ic_Comm_RxBuf[8] = Ic_Err_Flag; // 存入错误码
			memset(&ICEsamComm.Ic_Comm_RxBuf[0] , 0xFF , 8); // 填充缓冲区前部
			return; // 返回
		}
		// 如果fnICEsam_CheckCard()成功，会继续向下执行
	}
	
	// 卡操作成功或电压过低都会执行到这里？逻辑似乎需要调整，电压过低应直接返回错误。
	// 假设CheckCard成功后执行到此
	
	// 设置波特率为初始值
	ISO7816->BDDIV1 = 0X230000; // F/D = 768 (例如 2400bps)
	
	// 更新LCD显示成功信息
	fnLcd_SetSegment(SEG_DuKa, 1); // "读卡"
	fnLcd_SetSegment(SEG_Success, 1); // "成功"
	// 设置显示时间戳
	Dl645Session.Stamp = 3;
	Dl645Session.CardDispStamp = 3;
	Dl645Session.DisplyErrFlag = 0; // 清除显示刷新标志？
	fnLcd_RefreshLcdBuf(); // 刷新LCD
	
	// --- 卡操作完成后的处理 ---
	// 设置波特率为初始值？(可能为了后续停止时钟)
	ISO7816->BDDIV1 = 0X230000;
  	fnCardSendByte(CARD , 0x00); // 发送0x00，停止卡时钟
    I7816ComExt.EFlag = 0; // 清除卡插入标志
    ISO7816->CTRL1 |= 0x80000000; // 禁用ISO7816接口？
    CardFoutClose(); // 关闭卡座电源或使能信号？
#endif // METERTYPE == 1
}



