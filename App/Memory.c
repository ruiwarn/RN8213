/*
 * @file: Memory.c
 * @brief: 提供对外部非易失性存储器（如EEPROM AT24C256 或 FRAM FM24CXX）的读写封装接口。
 * @author: [Auto-generated by Roo]
 * @date: 2025/04/11
 * @description: 封装了底层的存储器驱动函数，增加了地址范围检查，并支持软件调试模式。
 */
#define  _DL645_MEMORY_GLOBALS // 用于全局变量实例化（如果Memory.h中有的话）
#include <App.h> // 包含应用层主头文件

/**
 * @brief 从非易失性存储器读取数据。
 * @param Dst 指向存储读取数据的目标缓冲区。
 * @param Src 要读取的存储器绝对地址。
 * @param DatLen 要读取的数据长度（字节）。
 * @return ErrorStatus SUCCESS表示读取成功，ERROR表示失败（地址超出范围或底层驱动错误）。
 * @note - 地址参数 Src 是存储器的绝对地址。
 *       - 函数内部会进行地址范围检查，防止越界访问。
 *       - 底层实际调用 fnFM24CXX_Read 函数（驱动层）。
 *       - 在软件调试模式 (DL645SOFT_DEBUG == 1) 下，不执行实际的硬件读操作。
 */
ErrorStatus fnMemory_Read(u8 *Dst , u32 Src , u32 DatLen)
{
	ErrorStatus err = SUCCESS; // 初始化错误状态为成功

	// 检查读取地址范围是否在定义的AT24C256存储空间内
	if( (AT24C256_START_ADDR <= Src) &&
		( (Src + DatLen) <= (AT24C256_START_ADDR + AT24C256_SIZE) ) ) // 结束地址应包含边界
	{
		#if  !DL645SOFT_DEBUG // 如果不是软件调试模式
		// 调用底层驱动函数读取数据
		// Src - AT24C256_START_ADDR: 将绝对地址转换为芯片内相对地址
		// 3: 可能是重试次数或其他参数
		err = fnFM24CXX_Read(Dst , Src - AT24C256_START_ADDR , DatLen , 3);
		#endif
	}
	else // 地址超出范围
	{
		err = ERROR; // 设置错误状态
	}
	
	return err; // 返回操作结果
}

/**
 * @brief 向非易失性存储器写入数据。
 * @param Dst 要写入的存储器绝对地址。
 * @param Src 指向包含待写入数据的源缓冲区。
 * @param DatLen 要写入的数据长度（字节）。
 * @return ErrorStatus SUCCESS表示写入成功，ERROR表示失败（地址超出范围或底层驱动错误）。
 * @note - 地址参数 Dst 是存储器的绝对地址。
 *       - 函数内部会进行地址范围检查，防止越界访问。
 *       - 底层实际调用 fnFM24CXX_Write 函数（驱动层）。
 *       - 在软件调试模式 (DL645SOFT_DEBUG == 1) 下，不执行实际的硬件写操作。
 */
ErrorStatus fnMemory_Write(u32 Dst , u8 *Src , u32 DatLen)
{
	ErrorStatus err = SUCCESS; // 初始化错误状态为成功

	// 检查写入地址范围是否在定义的AT24C256存储空间内
	if( (AT24C256_START_ADDR <= Dst) &&
		( (Dst + DatLen) <= (AT24C256_START_ADDR + AT24C256_SIZE) ) ) // 结束地址应包含边界
	{
		#if  !DL645SOFT_DEBUG // 如果不是软件调试模式
		// 调用底层驱动函数写入数据
		// Dst - AT24C256_START_ADDR: 将绝对地址转换为芯片内相对地址
		// 3: 可能是重试次数或其他参数
		err = fnFM24CXX_Write( Dst - AT24C256_START_ADDR , Src , DatLen , 3);
		#endif
	}
	else // 地址超出范围
	{
		err = ERROR; // 设置错误状态
	}
	return err; // 返回操作结果
}




