/*
 * @file: Dl645B_Com.c
 * @brief: 实现DL/T645-2007通信协议，处理接收到的命令，特别是参数设置和校准命令。
 * @author: [Auto-generated by Roo]
 * @date: 2025/04/11
 * @description: 此文件包含DL/T645协议的帧校验、数据处理、打包/解包以及参数设置（包括校准）的逻辑。
 *               注释已添加以解释寄存器操作和关键流程，目标是让新手易懂。
 */

#define  DL645B_COM_GLOBALS
#include <App.h>

/**
 * @brief 软件延时函数，大约延时5ms（基于8MHz时钟）。
 * @param None
 * @return None
 * @note 实际延时时间依赖于系统时钟频率和编译器优化。
 */
void fnDelay_5ms(void)
{
	u16 i;
	for(i=0; i<=14000; i++) // 循环次数根据时钟频率估算
	{
		__NOP(); // 空操作指令，用于消耗CPU周期
		__NOP();
	}	// 大约20MS @ 8MHz? 注释似乎有误，需要确认。
	return;
}

/**
 * @brief 字节数组反转函数。
 * @param Buf 指向要反转的字节数组的指针。
 * @param Len 数组的长度。
 * @return None
 */
void fnDl645B_Inverse(u8 *Buf, u8 Len)
{
	u8 i, Temp08;
	
	for( i=0; i<Len/2; i++ ) // 只需遍历一半长度
	{
		Temp08 = Buf[i]; // 交换首尾对应的字节
		Buf[i] = Buf[Len-1-i];
		Buf[Len-1-i] = Temp08;
	}
}

/**
 * @brief 检查单个字节是否为有效的BCD码。
 * @param Value 要检查的字节。
 * @return ErrorStatus SUCCESS表示有效，ERROR表示无效。
 */
ErrorStatus fnDl645B_ByteCheckBCD( u8 Value )
{
	// BCD码每个半字节（nibble）的值应在0-9之间
	if( ((Value & 0xF0) <= 0x90) && ((Value & 0x0F) <= 0x09) )
	{
		return SUCCESS;
	}
	else
	{
		return ERROR;
	}
}

/**
 * @brief 检查字节数组中的所有字节是否为有效的BCD码。
 * @param Buf 指向要检查的字节数组的指针。
 * @param Len 数组的长度。
 * @return ErrorStatus SUCCESS表示全部有效，ERROR表示存在无效BCD码。
 */
ErrorStatus fnDl645B_FramCheckBCD( u8 *Buf, u8 Len )
{
	u8 i;
	
	for( i=0; i<Len; i++ )
	{
		if( fnDl645B_ByteCheckBCD(Buf[i]) != SUCCESS ) return ERROR; // 逐字节检查
	}
	
	return SUCCESS;
}


/**
 * @brief 比较设置的时间（不含星期）是否在合法范围内并为BCD码。
 * @param Start Max/Min数组的起始索引（0:秒, 1:分, 2:时, 3:日, 4:月, 5:年）。
 * @param Ck 指向要检查的时间数据数组（BCD码）。
 * @param Len 要检查的时间数据长度。
 * @return ErrorStatus SUCCESS表示合法，ERROR表示非法。
 */
ErrorStatus fnDl645B_JudgeClockNoWeek( u8 Start, u8 *Ck, u8 Len )
{
	u8  i;
	// 定义时间各字段的最大值和最小值（BCD格式）
	u8 Max[]={ 0x59, 0x59, 0x23, 0x31, 0x12, 0x99 }; // 秒, 分, 时, 日, 月, 年
	u8 Min[]={ 0x00, 0x00, 0x00, 0x01, 0x01, 0x00 }; // 秒, 分, 时, 日, 月, 年

	for( i=0; i<Len; i++ )
	{
		// 检查是否超出范围
		if( (Ck[i] > Max[i+Start]) || (Ck[i] < Min[i+Start]) ) return ERROR; // 合法性检查错误
		// 检查是否为有效BCD码
		if( fnDl645B_ByteCheckBCD(Ck[i]) != SUCCESS ) return ERROR;	// BCD码检查错误
	}
	
	return SUCCESS; // 正确
}

/**
 * @brief 检查DL/T645通信地址是否匹配或为广播/通配地址。
 * @param ComAddr 指向接收到的通信地址（6字节）。
 * @param AFN 应用层功能码。
 * @return ErrorStatus SUCCESS表示地址匹配或有效，ERROR表示地址错误。
 */
ErrorStatus fnDl645B_AddrCheck(u8 *ComAddr , u8 AFN)
{
	const u8	BcAddr[] = {0x99, 0x99, 0x99, 0x99, 0x99, 0x99};	// 广播地址
	const u8	RdAddr[] = {0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa}; // 通配地址
	
	u8			MtAddr[6];		// 存储本机地址
	s8 			i , Flag;
	
	// 检查是否为广播地址，并限制允许广播的AFN
	if( (memcmp(&ComAddr[0] , &BcAddr , 6) == 0) &&
		( (AFN == 0x08) || (AFN == 0x16) || (AFN == 0x1D)) ) return SUCCESS; // 广播校时(0x08)、冻结命令(0x16)、中继命令(0x1D)允许广播
	
	// 检查是否为通配地址或本机地址
	if(memcmp(&ComAddr[0] , &RdAddr , 6) != 0) // 如果不是全AA通配地址
	{
		// 读取本机通信地址
		fnDl645File_Read(Dl645FileId_HighPara , Dl645FileItemInfoOffAddr_HighPara_ComAddr , &MtAddr , 6 );
	
		// 逐字节比较，支持通配符AA
		for(Flag = 0 , i = 5 ; i >= 0 ; i--)
		{
			if(ComAddr[i] != MtAddr[i]) // 如果字节不匹配
			{
				if( ComAddr[i] != 0xAA ) return ERROR; // 如果不是通配符AA，则地址错误
				if(Flag) return ERROR; // 如果已经匹配过更高位，则不允许低位再出现通配符
			}
			else Flag = 1; // 标记该位及更高位已匹配
		}
	}
	return SUCCESS; // 地址有效
}

/**
 * @brief 检查DL/T645-2007协议帧的有效性。
 * @param pCheck 指向接收到的帧结构体。
 * @return ErrorStatus SUCCESS表示帧有效，ERROR表示帧无效。
 */
ErrorStatus	fnDl645B_FrameCheck(sFrmDl645B_TypeDef *pCheck)
{
	const u8	BcAddr[] = {0x99, 0x99, 0x99, 0x99, 0x99, 0x99};	// 广播地址
	
	// 检查帧头
	if(pCheck->Head1 != 0x68) return ERROR;
	if(pCheck->Head2 != 0x68) return ERROR;
	
	// 特殊处理液晶查看命令的地址检查（允许广播）
	if((pCheck->AFN == 0x11) && (pCheck->UDat.DI0 == 0x33) && (pCheck->UDat.DI1 == 0x36) && (pCheck->UDat.DI2 == 0x37) && (pCheck->UDat.DI3 == 0x37)) // 液晶查看命令 (DI=0x37373633)
	{
		if( memcmp(pCheck->Addr , &BcAddr , 6) != 0) // 如果不是广播地址
		{
			if(fnDl645B_AddrCheck(pCheck->Addr , pCheck->AFN) != SUCCESS) return ERROR; // 检查地址是否匹配
		}
	}
	else // 其他命令
	{
		if(fnDl645B_AddrCheck(pCheck->Addr , pCheck->AFN) != SUCCESS) return ERROR; // 检查地址是否匹配
	}
	
	// 检查AFN是否在允许范围内（此处限制了部分AFN，可能需要根据实际需求调整）
	if(pCheck->AFN != 0x03 && pCheck->AFN != 0x08 && pCheck->AFN < 0x10) return ERROR;
	
	// 检查校验和
	if(pCheck->UDat.Dat[pCheck->Len - 4 + 0] != fnSum(&pCheck->Head1 , pCheck->Len + 10) ) return ERROR; // 计算校验和并比较
	// 检查帧尾
	if(pCheck->UDat.Dat[pCheck->Len - 4 + 1] != 0x16) return ERROR;
	
	return SUCCESS; // 帧有效
}

/**
 * @brief 对数据区进行加/减0x33操作（DL/T645协议要求）。
 * @param pModify 指向要操作的数据区。
 * @param Len 数据区长度。
 * @param OpFlag 操作标志：1表示加0x33，0表示减0x33。
 * @return None
 */
void fnDl645B_Modify(u8 *pModify , u16 Len , u8 OpFlag)
{
	if(OpFlag) // 加0x33
	{
		for( ; Len != 0 ; Len--)
		{
			*pModify = *pModify + 0x33;
			pModify++;
		}
	}
	else // 减0x33
	{
		for( ; Len != 0 ; Len--)
		{
			*pModify = *pModify - 0x33;
			pModify++;
		}
	}
}

/**
 * @brief 打包DL/T645错误响应帧。
 * @param TxFrm 指向发送帧缓冲区的指针。
 * @param RxFrm 指向接收帧的指针（用于获取地址和AFN）。
 * @param ErrInfo 错误信息码。
 * @return u16 打包后的帧长度。
 */
u16	fnDl645_PackErr(sFrmDl645B_TypeDef *TxFrm , sFrmDl645B_TypeDef *RxFrm , eDL645B_ErrInfo_TypeDef ErrInfo)
{																		// 返回错误桢
	TxFrm->Head1 = 0x68; // 帧起始符
	fnDl645File_Read(Dl645FileId_HighPara , Dl645FileItemInfoOffAddr_HighPara_ComAddr , &TxFrm->Addr , 6 );	// 读取本机地址填入
	TxFrm->Head2 = 0x68; // 地址域后帧起始符
	
	TxFrm->AFN = RxFrm->AFN; // 应用功能码与请求帧一致
	TxFrm->Persist = 0; // 后续帧标志
	TxFrm->Dir = 1; // 方向位：1表示从站到主站
	
	if(ErrInfo != DL645B_ERRINFO_OK) // 如果是错误应答
	{
		TxFrm->Ack = 1; // 确认/否认标志：1表示否认（异常）
		TxFrm->Len = 1;	// 数据域长度为1（错误码）
		TxFrm->UDat.DI0 = ErrInfo; // 错误码
		
		fnDl645B_Modify(&TxFrm->UDat.DI0 , TxFrm->Len , 1);	// 对数据域加0x33
		TxFrm->UDat.DI1 = fnSum(&TxFrm->Head1 , TxFrm->Len + 10); // 计算校验和
		TxFrm->UDat.DI2 = 0x16; // 结束符
	}
	else // 如果是正常应答（无数据）
	{
		TxFrm->Ack = 0; // 确认/否认标志：0表示确认（正常）
		TxFrm->Len = 0;	// 数据域长度为0
			
		fnDl645B_Modify(&TxFrm->UDat.DI0 , TxFrm->Len , 1);	// 对数据域加0x33（长度为0，实际无操作）
		TxFrm->UDat.DI0 = fnSum(&TxFrm->Head1 , TxFrm->Len + 10); // 计算校验和
		TxFrm->UDat.DI1 = 0x16; // 结束符
	}
	
	return(TxFrm->Len + 12); // 返回总帧长
}

/**
 * @brief 打包DL/T645正常响应帧（带数据标识）。
 * @param TxFrm 指向发送帧缓冲区的指针。
 * @param RxFrm 指向接收帧的指针（用于获取地址、AFN和数据标识）。
 * @param Len 数据域长度（不包括数据标识）。
 * @return u16 打包后的帧长度。
 */
u16	fnDl645_PackOk(sFrmDl645B_TypeDef *TxFrm , sFrmDl645B_TypeDef *RxFrm , u16 Len)
{
	TxFrm->Head1 = 0x68; // 帧起始符
	fnDl645File_Read(Dl645FileId_HighPara , Dl645FileItemInfoOffAddr_HighPara_ComAddr , &TxFrm->Addr , 6 );	// 读取本机地址
	TxFrm->Head2 = 0x68; // 地址域后帧起始符
	
	TxFrm->AFN = RxFrm->AFN; // 应用功能码
	TxFrm->Persist = 0; // 后续帧标志
	TxFrm->Ack = 0; // 确认/否认标志：0表示确认（正常）
	TxFrm->Dir = 1; // 方向位：1表示从站到主站
	
	TxFrm->Len = Len; // 数据域长度（包含数据标识）
	
	// 复制请求帧的数据标识DI0-DI3
	TxFrm->UDat.DI0 = RxFrm->UDat.DI0;
	TxFrm->UDat.DI1 = RxFrm->UDat.DI1;
	TxFrm->UDat.DI2 = RxFrm->UDat.DI2;
	TxFrm->UDat.DI3 = RxFrm->UDat.DI3;
	// 对整个数据域（包括数据标识和数据）加0x33
	fnDl645B_Modify(&TxFrm->UDat.DI0 , TxFrm->Len , 1);
	
	// 计算校验和并放置在数据域末尾
	TxFrm->UDat.Dat[TxFrm->Len - 4 + 0] = fnSum(&TxFrm->Head1 , TxFrm->Len + 10);
	TxFrm->UDat.Dat[TxFrm->Len - 4 + 1] = 0x16; // 结束符
	
	return(TxFrm->Len + 12); // 返回总帧长
}

/**
 * @brief 打包DL/T645正常响应帧（不带数据标识）。
 * @param TxFrm 指向发送帧缓冲区的指针。
 * @param RxFrm 指向接收帧的指针（用于获取地址和AFN）。
 * @param Len 数据域长度。
 * @return u16 打包后的帧长度。
 */
u16	fnDl645_PackNoDI(sFrmDl645B_TypeDef *TxFrm , sFrmDl645B_TypeDef *RxFrm , u16 Len)
{
	TxFrm->Head1 = 0x68; // 帧起始符
	fnDl645File_Read(Dl645FileId_HighPara , Dl645FileItemInfoOffAddr_HighPara_ComAddr , &TxFrm->Addr , 6 );	// 读取本机地址
	TxFrm->Head2 = 0x68; // 地址域后帧起始符
	
	TxFrm->AFN = RxFrm->AFN; // 应用功能码
	TxFrm->Persist = 0; // 后续帧标志
	TxFrm->Ack = 0; // 确认/否认标志：0表示确认（正常）
	TxFrm->Dir = 1; // 方向位：1表示从站到主站
	
	TxFrm->Len = Len; // 数据域长度
	
	// 对数据域加0x33
	fnDl645B_Modify(&TxFrm->UDat.DI0 , TxFrm->Len , 1);
	
	// 计算校验和并放置在数据域末尾
	TxFrm->UDat.Dat[TxFrm->Len - 4 + 0] = fnSum(&TxFrm->Head1 , TxFrm->Len + 10);
	TxFrm->UDat.Dat[TxFrm->Len - 4 + 1] = 0x16; // 结束符
	
	return(TxFrm->Len + 12); // 返回总帧长
}

/**
 * @brief 读取SOC内部寄存器映射区的数据（EMU或RTC）。
 * @param RxFrm 指向接收帧的指针，包含数据标识符(DI)。
 * @param Dst 指向目标缓冲区的指针。
 * @param Len 指向存储读取长度的变量的指针。
 * @return eDL645B_ErrInfo_TypeDef 错误码，DL645B_ERRINFO_OK表示成功。
 */
eDL645B_ErrInfo_TypeDef fnDl645_GetSocMemory(sFrmDl645B_TypeDef *RxFrm, u8 *Dst , u16 *Len)
{
	u32 DI; // 数据标识符
	
	*Len = 0; // 初始化长度为0
	DI = 0;
	// 从接收帧中组合数据标识符DI
	DI = ((u32)RxFrm->UDat.DI2 << 8) + (RxFrm->UDat.DI1 );
	DI = (DI << 8);
    DI = DI + (RxFrm->UDat.DI0);
    DI = DI & 0xFFFFFF00; // 取高24位作为基地址判断
	
	switch(DI)
	{
		case 0x00F81300: // 假设此DI范围对应EMU寄存器区
			*Len = 4; // 读取4字节
			// 从EMU寄存器映射区读取数据，偏移量由DI0决定
			memcpy(Dst , (u8 *)&Dl645B_EMUCom->Buf[RxFrm->UDat.DI0] , *Len);
			break;
		case 0x00F91100: // 假设此DI范围对应RTC寄存器区
			*Len = 4; // 读取4字节
			// 从RTC寄存器映射区读取数据，偏移量由DI0决定
			memcpy(Dst , (u8 *)&Dl645B_RTCCom->Buf[RxFrm->UDat.DI0] , *Len);
			break;
		default:
			return DL645B_ERRINFO_DATA; // 无效的数据标识
	}
	return DL645B_ERRINFO_OK; // 读取成功
}

/**
 * @brief 获取参数信息文件中的数据（主要为日期和时间）。
 * @param DI2 数据标识符高字节。
 * @param DI1 数据标识符中字节。
 * @param DI0 数据标识符低字节。
 * @param Dst 指向目标缓冲区的指针。
 * @param Len 指向存储读取长度的变量的指针。
 * @return eDL645B_ErrInfo_TypeDef 错误码，DL645B_ERRINFO_OK表示成功。
 */
eDL645B_ErrInfo_TypeDef fnDl645_GetParaVar(u8 DI2 , u8 DI1 , u8 DI0 , u8 *Dst , u16 *Len)
{
	u32 DI; // 数据标识符
	
	*Len = 0; // 初始化长度
	DI = 0;
	// 组合数据标识符
	DI = ((u32)DI2 << 8) + (DI1 );
	DI = (DI << 8);
    DI = DI + (DI0);
	
	switch(DI)
	{
	case 0x00000101: // 读取日期（年、月、日、星期）
		if(SysClock.Week == 0x07) Dst[0] = 0; // 星期日特殊处理为0？
		else Dst[0] = SysClock.Week;
		Dst[1] = SysClock.Day;
		Dst[2] = SysClock.Month;
		Dst[3] = SysClock.Year;
		*Len = 4; // 长度为4字节
		break;
	case 0x00000102: // 读取时间（时、分、秒）
		Dst[0] = SysClock.Second;
		Dst[1] = SysClock.Minute;
		Dst[2] = SysClock.Hour;
		*Len = 3; // 长度为3字节
		break;
	case 0x0000010c: // 读取日期和时间（秒、分、时、星期、日、月、年）
		if(SysClock.Week == 0x07) Dst[3] = 0; // 星期日特殊处理
		else Dst[3] = SysClock.Week;
		Dst[4] = SysClock.Day;
		Dst[5] = SysClock.Month;
		Dst[6] = SysClock.Year;
		Dst[0] = SysClock.Second;
		Dst[1] = SysClock.Minute;
		Dst[2] = SysClock.Hour;
		*Len = 7; // 长度为7字节
		break;
	default:
		return DL645B_ERRINFO_MISC; // 其他不支持的数据标识
	}
	return DL645B_ERRINFO_OK; // 获取成功
}

/**
 * @brief 获取当前变量数据（瞬时量）。
 * @param DI2 数据标识符高字节。
 * @param DI1 数据标识符中字节。
 * @param DI0 数据标识符低字节。
 * @param Dst 指向目标缓冲区的指针。
 * @param Len 指向存储读取长度的变量的指针。
 * @return eDL645B_ErrInfo_TypeDef 错误码，DL645B_ERRINFO_OK表示成功。
 */
eDL645B_ErrInfo_TypeDef fnDl645_GetVar(u8 DI2 , u8 DI1 , u8 DI0 , u8 *Dst , u16 *Len)
{
	u32 DI; // 数据标识符
	uDFAll DFAll; // 用于数据格式转换的联合体
	u16 ItemLen , i; // 临时变量
	
	*Len = 0; // 初始化长度
	// 组合数据标识符
    DI = ((u32)DI2 << 8) + (DI1 );
    DI = (DI << 8);
    DI = DI + (DI0);

	switch(DI)
	{
	case 0x00010100: // 读取电压
		DFAll.DF07 = fnDFConver_Bcd16ToDF07(Dl645Front.PubData.U); // 转换电压数据格式
		ItemLen = sizeof(sDF07); // 获取数据长度
		memcpy(Dst , &DFAll.DF07 , ItemLen); // 复制数据到目标缓冲区
		*Len = ItemLen; // 更新长度
		break;

	case 0x0001FF00: // 读取三相电压（单相表只提供A相）
		for(i = 0 ; i < 3 ; i++)
		{
			if(i == 0) DFAll.DF07 = fnDFConver_Bcd16ToDF07(Dl645Front.PubData.U); // A相电压
			else DFAll.DF07.Dat = 0xFFFF; // B、C相填充无效值
			ItemLen = sizeof(sDF07);
			memcpy(Dst , &DFAll.DF07 , ItemLen);
			*Len += ItemLen;
			Dst += ItemLen;
		}
		break;
	case 0x00020100: // 读取电流
		DFAll.DF25 = fnDFConver_Bcd32ToDF25(Dl645Front.PubData.Ia); // 转换电流数据格式
		ItemLen = sizeof(sDF25);
		memcpy(Dst , &DFAll.DF25 , ItemLen);
		*Len = ItemLen;
		break;

	case 0x0002FF00: // 读取三相电流（单相表只提供A相）
		DFAll.DF25 = fnDFConver_Bcd32ToDF25(Dl645Front.PubData.Ia); // A相电流
		ItemLen = sizeof(sDF25);
		memcpy(Dst , &DFAll.DF25 , ItemLen);
		Dst += ItemLen;
		memset(Dst , 0xFF , ItemLen); // B相填充无效值
		Dst += ItemLen;
		memset(Dst , 0xFF , ItemLen); // C相填充无效值
		*Len = ItemLen * 3;
		break;
//-----------
	case 0x00030000: // 读取总瞬时有功功率
	case 0x00030100: // 读取A相瞬时有功功率
		ItemLen = sizeof(sDF09);
		memcpy(Dst , &Dl645Front.PubData.Pw , ItemLen); // 复制功率数据
		*Len += ItemLen;
		break;

	case 0x0003FF00: // 读取总及各相瞬时有功功率
		ItemLen = sizeof(sDF09);
		memcpy(Dst , &Dl645Front.PubData.Pw , ItemLen); // 总有功
		Dst += ItemLen;
		memcpy(Dst , &Dl645Front.PubData.Pw , ItemLen); // A相有功
		Dst += ItemLen;
		memset(Dst , 0xFF , ItemLen); // B相填充无效值
		Dst += ItemLen;
		memset(Dst , 0xFF , ItemLen); // C相填充无效值
		Dst += ItemLen;
		*Len = ItemLen * 4;
		break;

	case 0x00060000: // 读取总功率因数
	case 0x00060100: // 读取A相功率因数
		ItemLen = sizeof(sDF26);
		memcpy(Dst , &Dl645Front.PubData.Pf , ItemLen); // 复制功率因数数据
		*Len += ItemLen;
		break;
	case 0x0006FF00: // 读取总及各相功率因数
		ItemLen = sizeof(sDF26);
		memcpy(Dst , &Dl645Front.PubData.Pf , ItemLen); // 总功率因数
		Dst += ItemLen;
		memcpy(Dst , &Dl645Front.PubData.Pf , ItemLen); // A相功率因数
		Dst += ItemLen;
		memset(Dst , 0xFF , ItemLen); // B相填充无效值
		Dst += ItemLen;
		memset(Dst , 0xFF , ItemLen); // C相填充无效值
		Dst += ItemLen;
		*Len = ItemLen * 4;
		break;
	case 0x00070100: // 读取A相相角
		ItemLen = sizeof(sDF26);
		memcpy(Dst , &Dl645Front.PubData.Angle , ItemLen); // 复制相角数据
		*Len = ItemLen;
		break;
	case 0x0007FF00: // 读取各相相角
		ItemLen = sizeof(sDF26);
		memcpy(Dst , &Dl645Front.PubData.Angle , ItemLen); // A相相角
		Dst += ItemLen;
		memset(Dst , 0xFF , ItemLen); // B相填充无效值
		Dst += ItemLen;
		memset(Dst , 0xFF , ItemLen); // C相填充无效值
		Dst += ItemLen;
		*Len = ItemLen * 3;
		break;
	case 0x00800001: // 读取零线电流
		DFAll.DF25 = fnDFConver_Bcd32ToDF25(Dl645Front.PubData.In); // 转换零线电流数据格式
		ItemLen = sizeof(sDF25);
		memcpy(Dst , &DFAll.DF25 , ItemLen);
		*Len = ItemLen;
		break;
	case 0x00800002: // 读取电网频率
		DFAll.DF33 = fnDFConver_Bcd16ToDF33(Dl645Front.PubData.Frequency); // 转换频率数据格式
		ItemLen = sizeof(sDF33);
		memcpy(Dst , &DFAll.DF33 , ItemLen);
		*Len = ItemLen;
		break;
	case 0x00800007: // 读取当前表内温度
		ItemLen = sizeof(u16);
		memcpy(Dst , &Dl645Front.PubData.Temperature , ItemLen); // 复制温度数据
		*Len = ItemLen;
		break;
	case 0x00800008: // 读取时钟电池电压
		DFAll.DF33 = fnDFConver_Bcd16ToDF33(Dl645Front.PubData.ClockBat); // 转换电池电压数据格式
		ItemLen = sizeof(sDF33);
		memcpy(Dst , &DFAll.DF33 , ItemLen);
		*Len = ItemLen;
		break;
	default:
		return DL645B_ERRINFO_DATA; // 不支持的数据标识
	}
	return DL645B_ERRINFO_OK; // 获取成功
}

/**
 * @brief 处理参数设置命令（AFN=0x14）。
 * @param RxFrm 指向接收到的DL/T645帧。
 * @return eDL645B_ErrInfo_TypeDef 错误码，DL645B_ERRINFO_OK表示成功。
 */
eDL645B_ErrInfo_TypeDef fnDl645_PutParaVar(sFrmDl645B_TypeDef *RxFrm)
{
	u8  i; // 循环计数器
	u32 DI; // 数据标识符
	u16 tempconst; // 临时存储电表常数
	u16	temphfconst; // 临时存储高频常数
	u32 tempus, tempis, tempub, tempib; // 临时存储电压、电流标准值和基准值
	sDF10	ConstE; // 电表常数（BCD格式）
	float ADErr; // 误差计算变量
	u32	temppw[2]; // 临时存储功率读数
	
	// 检查密码是否正确（硬编码密码）
	if((RxFrm->UDat.Dat[0] == 0x03) && (RxFrm->UDat.Dat[1] == 0x33) && (RxFrm->UDat.Dat[2] == 0x22) && (RxFrm->UDat.Dat[3] == 0x11)) ; // 密码: 0x11223303 ?
	else return DL645B_ERRINFO_PSW; // 密码错误
	
	// 组合数据标识符
	DI = 0;
	DI = ((u32)RxFrm->UDat.DI2 << 8) + (RxFrm->UDat.DI1 );
	DI = (DI << 8);
    DI = DI + (RxFrm->UDat.DI0);
	
	switch(DI)
	{
	case 0x00000101: // 设置日期 (YYMMDD)
		if(RxFrm->Len != (12 + 4) ) return DL645B_ERRINFO_MISC; // 检查帧长度
		if(fnDl645B_JudgeClockNoWeek( 3, &RxFrm->UDat.Dat[9], 3 ) == ERROR) return DL645B_ERRINFO_MISC; // 检查日期合法性
		if(RxFrm->UDat.Dat[9] > fnGetDay(RxFrm->UDat.Dat[10] , RxFrm->UDat.Dat[11])) return DL645B_ERRINFO_MISC; // 检查日是否超过当月最大天数
		SysClock.Day = RxFrm->UDat.Dat[9];
		SysClock.Month = RxFrm->UDat.Dat[10];
		SysClock.Year = RxFrm->UDat.Dat[11];
		
	    SysClock.Week = fnWeek_Calculate(SysClock.Year , SysClock.Month , SysClock.Day); // 计算星期
	    if(SysClock.Week == 7) SysClock.Week = 0; // 星期日处理
		
		if(fnSysClock_Write(&SysClock) == ERROR) return DL645B_ERRINFO_MISC; // 写入系统时钟
		Dl645Bkgrd.PubData.fChange.FlagBit.XiugaiClock = 1; // 设置时钟修改标志
		break;
	case 0x00000102: // 设置时间 (HHMMSS)
		if(RxFrm->Len != (12 + 3) ) return DL645B_ERRINFO_MISC; // 检查帧长度
		if(fnDl645B_JudgeClockNoWeek( 0, &RxFrm->UDat.Dat[8], 3 ) == ERROR) return DL645B_ERRINFO_MISC; // 检查时间合法性
		SysClock.Second = RxFrm->UDat.Dat[8];
		SysClock.Minute = RxFrm->UDat.Dat[9];
		SysClock.Hour = RxFrm->UDat.Dat[10];
		Dl645Bkgrd.PubData.ClockPiece = 0; // 清零时钟片段计数？
		Dl645Bkgrd.PubData.Second = SysClock.Second; // 更新后台秒计数
		if(fnSysClock_Write(&SysClock) == ERROR) return DL645B_ERRINFO_MISC; // 写入系统时钟
		Dl645Bkgrd.PubData.fChange.FlagBit.XiugaiClock = 1; // 设置时钟修改标志
		break;
	case 0x0000010c: // 设置日期和时间 (YYMMDDHHMMSS)
		if(RxFrm->Len != (12 + 7) ) return DL645B_ERRINFO_MISC; // 检查帧长度
		if(fnDl645B_JudgeClockNoWeek( 0, &RxFrm->UDat.Dat[8], 3 ) == ERROR) return DL645B_ERRINFO_MISC; // 检查时间合法性
		if(fnDl645B_JudgeClockNoWeek( 3, &RxFrm->UDat.Dat[12], 3 ) == ERROR) return DL645B_ERRINFO_MISC; // 检查日期合法性
		SysClock.Second = RxFrm->UDat.Dat[8];
		SysClock.Minute = RxFrm->UDat.Dat[9];
		SysClock.Hour = RxFrm->UDat.Dat[10];
		SysClock.Day = RxFrm->UDat.Dat[12];
		SysClock.Month = RxFrm->UDat.Dat[13];
		SysClock.Year = RxFrm->UDat.Dat[14];
		
	    SysClock.Week = fnWeek_Calculate(SysClock.Year , SysClock.Month , SysClock.Day); // 计算星期
	    if(SysClock.Week == 7) SysClock.Week = 0; // 星期日处理
		Dl645Bkgrd.PubData.ClockPiece = 0; // 清零时钟片段计数？
		Dl645Bkgrd.PubData.Second = SysClock.Second; // 更新后台秒计数
		if(fnSysClock_Write(&SysClock) == ERROR) return DL645B_ERRINFO_MISC; // 写入系统时钟
		break;
	case 0x00F81000: // A通道校准命令
		if(RxFrm->Len != (12 + 24)) return DL645B_ERRINFO_MISC; // 检查帧长度
		EMU->SPCMD = 0xE5; // 写SPCMD寄存器，解除写保护
		memcpy(&tempis , &(RxFrm->UDat.Dat[24]) , 4); // 获取标准电流值
		if(tempis != 0) // 标准电压电流方式校准
		{
			// 从接收帧中提取校准参数
			memcpy(&tempconst , &(RxFrm->UDat.Dat[8]) , 2); // 电表常数
			memcpy(&temphfconst , &(RxFrm->UDat.Dat[10]) , 2); // 高频常数
			memcpy(&tempub , &(RxFrm->UDat.Dat[12]) , 4); // 基准电压
			memcpy(&tempus , &(RxFrm->UDat.Dat[16]) , 4); // 标准电压
			memcpy(&tempib , &(RxFrm->UDat.Dat[20]) , 4); // 基准电流
			memcpy(&tempis , &(RxFrm->UDat.Dat[24]) , 4); // 标准电流
			
			// 写入高频常数
			Dl645FirmPara.HFConst = temphfconst;
			EMU->HFConst = Dl645FirmPara.HFConst; // 写入EMU->HFConst寄存器
			fnDl645File_Write(Dl645FileId_FirmPara, Dl645FileItemInfoOffAddr_FirmPara_HFConst, (u8 *)&Dl645FirmPara.HFConst, 2); // 保存到文件系统
			
			// 校准电压增益
			temppw[0] = EMU->URMS; // 读取当前电压RMS值
			ADErr = ((float)temppw[0] - (float)tempus) / tempus; // 计算电压误差
			ADErr = (-ADErr / (1 + ADErr)); // 计算增益调整系数
			if(ADErr > 0) Dl645FirmPara.UGain = (u16)(ADErr * 32768); // 计算正增益值
			else Dl645FirmPara.UGain = (u16)(65535 + ADErr * 32768); // 计算负增益值（补码）
			EMU->UGAIN = Dl645FirmPara.UGain; // 写入EMU->UGAIN寄存器
	
			// 校准电流增益
			temppw[0] = EMU->IARMS; // 读取当前A相电流RMS值
			ADErr = ((float)temppw[0] - (float)tempis) / tempis; // 计算电流误差
			ADErr = ((-ADErr) / (1 + ADErr)); // 计算增益调整系数
			if(ADErr > 0) Dl645FirmPara.IAGain = (u16)(ADErr * 32768); // 计算正增益值
			else Dl645FirmPara.IAGain = (u16)(65535 + ADErr * 32768); // 计算负增益值（补码）
			EMU->IAGAIN = Dl645FirmPara.IAGain; // 写入EMU->IAGAIN寄存器
			fnDl645File_Write(Dl645FileId_FirmPara, Dl645FileItemInfoOffAddr_FirmPara_IAGAIN, (u8 *)&Dl645FirmPara.IAGain, 4); // 保存到文件系统（注意长度为4？）
			
			// 保存电表常数
			tempconst = fnHexToBcd_u16(tempconst); // 转换为BCD格式
			ConstE.Dat0 = (((u8)(tempconst & 0x000F)) << 4) & 0xF0;
			ConstE.Dat1 = (tempconst & 0x0FF0) >> 4;
			ConstE.Dat2 = (u8)((tempconst & 0xF000) >> 12);
			fnDl645File_Write(Dl645FileId_HighPara , Dl645FileItemInfoOffAddr_HighPara_PConstE , (u8 *)&ConstE , 3); // 保存到文件系统
			
			// 计算并保存电流、电压系数
			Dl645FirmPara.KIArms = (float)tempis / ((float)tempib);
			Dl645FirmPara.KUrms = (float)tempus * 100 / (tempub);
			
			// 计算并写入启动功率阈值
			ADErr = ((float)tempus * (float)tempis) / 32768; // 计算基准功率相关值
			Dl645FirmPara.PStart = (u16)((ADErr * 0.003) / 256); // 计算启动阈值
			EMU->PStart = Dl645FirmPara.PStart; // 写入EMU->PStart寄存器
			
			// 计算并保存功率系数
			Dl645FirmPara.KPrms = (ADErr / ((float)tempub * (float)tempib * 0.0000001));
		}
		else // 误差方式校准功率
		{
			// 从接收帧中提取校准参数
			memcpy(&tempconst , &(RxFrm->UDat.Dat[8]) , 2); // 电表常数
			memcpy(&temphfconst , &(RxFrm->UDat.Dat[10]) , 2); // 高频常数
			memcpy(&tempub , &(RxFrm->UDat.Dat[12]) , 4); // 基准电压
			memcpy(&tempib , &(RxFrm->UDat.Dat[20]) , 4); // 基准电流
			memcpy(&tempis , &(RxFrm->UDat.Dat[28]) , 4); // 功率误差值
			
			// 写入高频常数
			Dl645FirmPara.HFConst = temphfconst;
			EMU->HFConst = Dl645FirmPara.HFConst; // 写入EMU->HFConst寄存器
			fnDl645File_Write(Dl645FileId_FirmPara, Dl645FileItemInfoOffAddr_FirmPara_HFConst, (u8 *)&Dl645FirmPara.HFConst, 2); // 保存到文件系统
			
			// 校准功率相位（使用误差）
			if(tempis > 0x7FFFFFFF) ADErr = -(float)(0xFFFFFFFF - tempis) / 100000; // 处理负误差
        	else ADErr = (float)tempis / 100000; // 正误差
			ADErr = ((-ADErr) / (1 + ADErr)); // 计算调整系数
			if(ADErr >= 0) Dl645FirmPara.GPQA = (u16)(ADErr * 32768); // 计算正调整值
			else Dl645FirmPara.GPQA = (u16)(65535 + ADErr * 32768); // 计算负调整值（补码）
			EMU->GPQA = Dl645FirmPara.GPQA; // 写入EMU->GPQA寄存器
			fnDl645File_Write(Dl645FileId_FirmPara, Dl645FileItemInfoOffAddr_FirmPara_GPQA, (u8 *)&Dl645FirmPara.GPQA, 2); // 保存到文件系统
			
			// 计算并保存电流、电压系数
			tempis = EMU->IARMS; // 读取当前电流
			Dl645FirmPara.KIArms = (float)tempis / ((float)tempib);
			tempus = EMU->URMS; // 读取当前电压
			Dl645FirmPara.KUrms = (float)tempus * 100 / (tempub);
			
			// 计算并写入启动功率阈值和功率系数
			ADErr = ((float)temphfconst * 4 * (float)tempconst * 10 * (float)tempub * (float)tempib * 21.47483648) / (3.6 * 1000000000000 * 1.8432); // 复杂公式计算基准功率相关值
			Dl645FirmPara.PStart = (u16)((ADErr * 0.003) / 256); // 计算启动阈值
			EMU->PStart = Dl645FirmPara.PStart; // 写入EMU->PStart寄存器
			Dl645FirmPara.KPrms = (ADErr / ((float)tempub * (float)tempib * 0.0000001)); // 计算功率系数
			
			// 保存电表常数
			tempconst = fnHexToBcd_u16(tempconst); // 转换为BCD
			ConstE.Dat0 = (((u8)(tempconst & 0x000F)) << 4) & 0xF0;
			ConstE.Dat1 = (tempconst & 0x0FF0) >> 4;
			ConstE.Dat2 = (u8)((tempconst & 0xF000) >> 12);
			fnDl645File_Write(Dl645FileId_HighPara , Dl645FileItemInfoOffAddr_HighPara_PConstE , (u8 *)&ConstE , 3); // 保存到文件系统
		}
		// 保存校准系数和校验和
		fnDl645File_Write(Dl645FileId_FirmPara, Dl645FileItemInfoOffAddr_FirmPara_KUrms, (u8 *)&Dl645FirmPara.KUrms, 16); // 保存KUrms, KIArms, KIBrms, KPrms (每个4字节，共16字节)
		Dl645FirmPara.ChkSum = 0; // 清零校验和准备重新计算
		SystemDelay(1); // 短暂延时
		Dl645FirmPara.ChkSum = EMU->EMUStatus; // 读取EMU状态寄存器作为校验和
		Dl645FirmPara.ChkSum &= 0x00FFFFFF; // 取低24位
		fnDl645File_Write(Dl645FileId_FirmPara, Dl645FileItemInfoOffAddr_FirmPara_ChkSum, (u8 *)&Dl645FirmPara.ChkSum, 4); // 保存校验和
		fnDl645File_Write(Dl645FileId_FirmPara, Dl645FileItemInfoOffAddr_FirmPara_PStart, (u8 *)&Dl645FirmPara.PStart, 2); // 保存启动阈值
		EMU->SPCMD = 0xDC; // 写SPCMD寄存器，恢复写保护
		break;
	case 0x00F81100: // A通道相位校正
		if(RxFrm->Len != (12 + 12)) return DL645B_ERRINFO_MISC; // 检查帧长度
		EMU->SPCMD = 0xE5; // 解除写保护
		memcpy(&tempub , &(RxFrm->UDat.Dat[8]) , 4); // 获取基准功率？
		memcpy(&tempus , &(RxFrm->UDat.Dat[12]) , 4); // 获取标准功率？
		memcpy(&tempis , &(RxFrm->UDat.Dat[16]) , 4); // 获取相位误差？
		if(tempub != 0 ) // 标准功率方式校准相位
		{
			temppw[0] = EMU->PowerPA; // 读取当前A相功率
			ADErr = ((float)temppw[0] - (float)tempus) / tempus; // 计算功率误差
			ADErr = (asin(-ADErr / 1.732)) * 100 * 57.29578; // 计算相位调整角度（弧度转角度，涉及功率因数？）
			if(ADErr > 0) Dl645FirmPara.PhsA = (u16)(ADErr); // 计算正调整值
			else Dl645FirmPara.PhsA = (u16)(512 + ADErr); // 计算负调整值（补码？）
		}
		else // 误差方式校准相位
		{
			if(tempis > 0x7FFFFFFF) ADErr = -(float)(0xFFFFFFFF - tempis) / 100000; // 处理负误差
        	else ADErr = (float)tempis / 100000; // 正误差
			ADErr = (asin(-ADErr / 1.732)) * 100 * 57.29578; // 计算相位调整角度
			if(ADErr > 0) Dl645FirmPara.PhsA = (u16)(ADErr); // 计算正调整值
			else Dl645FirmPara.PhsA = (u16)(512 + ADErr); // 计算负调整值
		}
		EMU->PhsA = Dl645FirmPara.PhsA; // 写入EMU->PhsA寄存器
		EMU->SPCMD = 0xDC; // 恢复写保护
		// 更新并保存校验和及相关参数
		Dl645FirmPara.ChkSum = 0;
		SystemDelay(1);
		Dl645FirmPara.ChkSum = EMU->EMUStatus;
		Dl645FirmPara.ChkSum &= 0x00FFFFFF;
		fnDl645File_Write(Dl645FileId_FirmPara, Dl645FileItemInfoOffAddr_FirmPara_ChkSum, (u8 *)&Dl645FirmPara.ChkSum, 4);
		fnDl645File_Write(Dl645FileId_FirmPara, Dl645FileItemInfoOffAddr_FirmPara_PhsA, (u8 *)&Dl645FirmPara.PhsA, 2);
		fnDl645File_Write(Dl645FileId_FirmPara, Dl645FileItemInfoOffAddr_FirmPara_KPrms, (u8 *)&Dl645FirmPara.KPrms, 4); // 保存功率系数
		break;
	case 0x00F81200: // 小电流校正
		if(RxFrm->Len != (12 + 6)) return DL645B_ERRINFO_MISC; // 检查帧长度
		EMU->SPCMD = 0xE5; // 解除写保护
		memcpy(&tempus , &(RxFrm->UDat.Dat[8]) , 4); // 获取标准功率？
		memcpy(&tempis , &(RxFrm->UDat.Dat[12]) , 2); // 获取误差或补偿值？
		if(tempus == 0 ) // 以输入的误差校正小电流
		{
			EMU->APOSA = tempis; // 直接写入补偿值到EMU->APOSA寄存器
			Dl645FirmPara.APOSA = tempis; // 保存补偿值
		}
		else // 根据当前功率和标准功率计算补偿值
		{
			temppw[0] = EMU->PowerPA; // 读取当前功率
			for(i = 0; i < 3; i++) // 多次读取求平均，提高稳定性
			{
				SystemDelay(250);
				temppw[1] = EMU->PowerPA;
				temppw[0] = (temppw[0] + temppw[1]) / 2;
			}
			ADErr = ((float)temppw[0] - (float)tempus) / tempus; // 计算功率误差
			ADErr = -ADErr * tempus; // 计算补偿值
			if(ADErr > 0) Dl645FirmPara.APOSA = (u16)(ADErr); // 计算正补偿值
			else Dl645FirmPara.APOSA = (u16)(65535 + ADErr); // 计算负补偿值（补码）
			EMU->APOSA = Dl645FirmPara.APOSA; // 写入EMU->APOSA寄存器
		}
		
		fnDl645File_Write(Dl645FileId_FirmPara, Dl645FileItemInfoOffAddr_FirmPara_APOSA, (u8 *)&Dl645FirmPara.APOSA, 2); // 保存补偿值
		// 更新并保存校验和
		Dl645FirmPara.ChkSum = 0;
		SystemDelay(1);
		Dl645FirmPara.ChkSum = EMU->EMUStatus;
		Dl645FirmPara.ChkSum &= 0x00FFFFFF;
		fnDl645File_Write(Dl645FileId_FirmPara, Dl645FileItemInfoOffAddr_FirmPara_ChkSum, (u8 *)&Dl645FirmPara.ChkSum, 4);
		EMU->SPCMD = 0xDC; // 恢复写保护
		break;
	case 0x00F81300: // B通道电流校正
		if(RxFrm->Len != (12 + 12)) return DL645B_ERRINFO_MISC; // 检查帧长度
		memcpy(&tempib , &(RxFrm->UDat.Dat[8]) , 4); // 获取基准电流
		tempis = EMU->IBRMS; // 读取当前B相电流RMS值
		Dl645FirmPara.KIBrms = (float)tempis / ((float)tempib); // 计算B通道电流系数
		fnDl645File_Write(Dl645FileId_FirmPara, Dl645FileItemInfoOffAddr_FirmPara_KIBrms, (u8 *)&Dl645FirmPara.KIBrms, 4); // 保存系数
		break;
	case 0x00F81400: // 对寄存器直接读写操作（调试用？）
		tempis = 0;
		memcpy(&tempis , &(RxFrm->UDat.Dat[8]) , (RxFrm->Len - 13)); // 获取要写入的值
		EMU->SPCMD = 0xE5; // 解除写保护
		// 将值写入由DI0指定的EMU寄存器映射区偏移地址
		Dl645B_EMUCom->Buf[RxFrm->UDat.Dat[10]] = tempis; // 注意：这里偏移量用了Dat[10]，可能需要确认
		EMU->SPCMD = 0xE5; // 再次解除写保护？似乎多余，应为0xDC
		break;
	case 0x00F81500: // 电流通道RMS Offset校正
		if(RxFrm->Len != (12 + 3)) return DL645B_ERRINFO_MISC; // 检查帧长度
		tempus = 0;
		EMU->SPCMD = 0xE5; // 解除写保护
		if(RxFrm->UDat.Dat[8] == 0x00) // 判断是A通道还是B通道 (0x00=A, 其他=B?)
		{
			memcpy(&tempus , &(RxFrm->UDat.Dat[9]) , 2); // 获取Offset值
			EMU->IARMSOS = tempus; // 写入A通道RMS Offset寄存器
			Dl645FirmPara.IARMSOS = tempus; // 保存Offset值
			fnDl645File_Write(Dl645FileId_FirmPara, Dl645FileItemInfoOffAddr_FirmPara_IARMSOS, (u8 *)&Dl645FirmPara.IARMSOS, 2); // 保存到文件
		}
		else
		{
			memcpy(&tempus , &(RxFrm->UDat.Dat[9]) , 2); // 获取Offset值
			EMU->IBRMSOS = tempus; // 写入B通道RMS Offset寄存器
			Dl645FirmPara.IBRMSOS = tempus; // 保存Offset值
			fnDl645File_Write(Dl645FileId_FirmPara, Dl645FileItemInfoOffAddr_FirmPara_IBRMSOS, (u8 *)&Dl645FirmPara.IBRMSOS, 2); // 保存到文件
		}
		// 更新并保存校验和
		Dl645FirmPara.ChkSum = 0;
		SystemDelay(1);
		Dl645FirmPara.ChkSum = EMU->EMUStatus;
		Dl645FirmPara.ChkSum &= 0x00FFFFFF;
		fnDl645File_Write(Dl645FileId_FirmPara, Dl645FileItemInfoOffAddr_FirmPara_ChkSum, (u8 *)&Dl645FirmPara.ChkSum, 4);
		EMU->SPCMD = 0xDC; // 恢复写保护
		break;
	case 0x00F81600: // 清零校准参数（恢复默认值）
		if((RxFrm->Len != (12 + 1)) || (RxFrm->UDat.Dat[8] != 0x5A)) return DL645B_ERRINFO_MISC; // 检查帧长度和确认码
		EMU->SPCMD = 0xE5; // 解除写保护
		// 设置校准参数为默认值
		Dl645FirmPara.UGain = 0;
		Dl645FirmPara.IAGain = 0;
		Dl645FirmPara.IBGain = 0xBFFF; // 特殊默认值？
		Dl645FirmPara.PhsA = 0;
		Dl645FirmPara.PhsB = 0;
		Dl645FirmPara.APOSA = 0;
		Dl645FirmPara.APOSB = 0;
		Dl645FirmPara.GPQA = 0;
		Dl645FirmPara.GPQB = 0;
		Dl645FirmPara.PStart = 0x60;
		Dl645FirmPara.QStart = 0x0120;
		Dl645FirmPara.IARMSOS = 0;
		Dl645FirmPara.IBRMSOS = 0;
		// 将默认值写入EMU寄存器
		EMU->PStart = 0x60;
		EMU->QStart = 0x0120;
		EMU->UGAIN = 0;
		EMU->IAGAIN = 0;
		EMU->IBGAIN = 0xBFFF;
		EMU->PhsA = 0;
		EMU->PhsB = 0;
		EMU->APOSA = 0;
		EMU->APOSB = 0;
		EMU->GPQA = 0;
		EMU->GPQB = 0;
		EMU->IARMSOS = 0;
		EMU->IBRMSOS = 0;
		EMU->SPCMD = 0xDC; // 恢复写保护
		// 将默认值保存到文件系统
		fnDl645File_Write(Dl645FileId_FirmPara, Dl645FileItemInfoOffAddr_FirmPara_PStart, (u8 *)&Dl645FirmPara.PStart, 22); // 保存PStart到RPOSB (共22字节)
		fnDl645File_Write(Dl645FileId_FirmPara, Dl645FileItemInfoOffAddr_FirmPara_IARMSOS, (u8 *)&Dl645FirmPara.IARMSOS, 4); // 保存IARMSOS, IBRMSOS (共4字节)
		// 更新并保存校验和
		Dl645FirmPara.ChkSum = 0;
		SystemDelay(1);
		Dl645FirmPara.ChkSum = EMU->EMUStatus;
		Dl645FirmPara.ChkSum &= 0x00FFFFFF;
		fnDl645File_Write(Dl645FileId_FirmPara, Dl645FileItemInfoOffAddr_FirmPara_ChkSum, (u8 *)&Dl645FirmPara.ChkSum, 4);
		break;
	case 0x00F81601: // B通道清零校准参数
		if((RxFrm->Len != (12 + 1)) || (RxFrm->UDat.Dat[8] != 0x5A)) return DL645B_ERRINFO_MISC; // 检查帧长度和确认码
		EMU->SPCMD = 0xE5; // 解除写保护
		// 设置B通道相关参数为默认值
		Dl645FirmPara.IBGain = 0;
		Dl645FirmPara.PhsB = 0;
		Dl645FirmPara.APOSB = 0;
		Dl645FirmPara.GPQB = 0;
		// 将默认值写入EMU寄存器
		EMU->IBGAIN = 0;
		EMU->PhsB = 0;
		EMU->APOSB = Dl645FirmPara.APOSB; // 这里似乎用了保存的值？应为0
		EMU->GPQB = 0;
		EMU->SPCMD = 0xE5; // 再次解除写保护？应为0xDC
		// 将默认值保存到文件系统
		fnDl645File_Write(Dl645FileId_FirmPara, Dl645FileItemInfoOffAddr_FirmPara_GPQA, (u8 *)&Dl645FirmPara.GPQA, 14); // 保存GPQA到RPOSB (共14字节)？范围似乎不对
		// 更新并保存校验和
		Dl645FirmPara.ChkSum = 0;
		SystemDelay(1);
		Dl645FirmPara.ChkSum = EMU->EMUStatus;
		Dl645FirmPara.ChkSum &= 0x00FFFFFF;
		fnDl645File_Write(Dl645FileId_FirmPara, Dl645FileItemInfoOffAddr_FirmPara_ChkSum, (u8 *)&Dl645FirmPara.ChkSum, 4);
		break;
	case 0x00F91100: // 设置RTC的DOTA0寄存器（数字校准）
		if(RxFrm->Len != (12 + 2)) return DL645B_ERRINFO_MISC; // 检查帧长度
		memcpy((u8 *)&Dl645FirmPara.RTCDota0 , &(RxFrm->UDat.Dat[8]) , 2); // 获取校准值
		RtcWriteDota(Dl645FirmPara.RTCDota0); // 调用函数写入RTC校准寄存器
		fnDl645File_Write(Dl645FileId_FirmPara, Dl645FileItemInfoOffAddr_FirmPara_RTCDota0, (u8 *)&Dl645FirmPara.RTCDota0, 2); // 保存校准值到文件
		break;
	default:
		return DL645B_ERRINFO_MISC; // 不支持的数据标识
	}
		
	return DL645B_ERRINFO_OK; // 参数设置成功
}

/**
 * @brief 处理读数据命令（AFN=0x11）。
 * @param ComPort 通信端口号。
 * @param RxFrm 指向接收到的DL/T645帧。
 * @return u16 响应帧的长度，0表示无响应。
 */
u16 fnDl645B_Unpack11(u8 ComPort , sFrmDl645B_TypeDef *RxFrm)	//读数据
{
	eDL645B_ErrInfo_TypeDef 	err; // 错误码
	u16 Len; // 数据长度
	
	sFrmDl645B_TypeDef *TxFrm; // 指向发送帧缓冲区
	TxFrm = (sFrmDl645B_TypeDef *)&ComPack[ComPort].TxBuf[DL645B_LEADERCODE_LEN]; // 获取发送缓冲区地址（跳过前导码）
	
	if(RxFrm->Len == 4) // 检查请求帧数据域长度是否为4（数据标识符）
	{
		switch(RxFrm->UDat.DI3) // 根据数据标识符的最高字节判断数据类型
		{
		case 0x02: err = fnDl645_GetVar(RxFrm->UDat.DI2 , RxFrm->UDat.DI1 , RxFrm->UDat.DI0 , &TxFrm->UDat.Dat[0] , &Len); break; // 读取变量数据
		case 0x04: err = fnDl645_GetParaVar(RxFrm->UDat.DI2 , RxFrm->UDat.DI1 , RxFrm->UDat.DI0 , &TxFrm->UDat.Dat[0] , &Len); break; // 读取参数信息
		case 0x06: err = fnDl645_GetSocMemory(RxFrm, &TxFrm->UDat.Dat[0] , &Len); break; // 读取SOC内存（寄存器）
		default: err = DL645B_ERRINFO_DATA; Len = 0; break; // 不支持的数据类型
		}
	}
	else
	{
		err = DL645B_ERRINFO_DATA; Len = 0; // 帧长度错误
	}
	
	// 根据读取结果打包响应帧
	if(err == DL645B_ERRINFO_OK) Len = fnDl645_PackOk(TxFrm , RxFrm , Len + 4); // 成功，打包正常响应帧（数据长度+4字节DI）
	else Len = fnDl645_PackErr(TxFrm , RxFrm , err); // 失败，打包错误响应帧
	
	return Len; // 返回响应帧长度
}

/**
 * @brief 处理读通信地址命令（AFN=0x13）。
 * @param ComPort 通信端口号。
 * @param RxFrm 指向接收到的DL/T645帧。
 * @return u16 响应帧的长度，0表示无响应或请求无效。
 */
u16 fnDl645B_Unpack13(u8 ComPort , sFrmDl645B_TypeDef *RxFrm) 	//读通信地址
{
	u8 i;
	u16 Len;
	sFrmDl645B_TypeDef *TxFrm;
	TxFrm = (sFrmDl645B_TypeDef *)&ComPack[ComPort].TxBuf[DL645B_LEADERCODE_LEN];

	// 读通信地址命令要求地址域为全AA
	for(i = 0 ; i < 6 ; i++)
	{
		if(RxFrm->Addr[i] != 0xAA) return 0; // 地址不是全AA，无效请求
	}
	if(RxFrm->Len != 0) return 0; // 数据域长度应为0，无效请求
	
	// 读取本机通信地址
	fnDl645File_Read(Dl645FileId_HighPara , Dl645FileItemInfoOffAddr_HighPara_ComAddr , &TxFrm->UDat.DI0 , 6);
	// 打包正常响应帧（不带数据标识）
	Len = fnDl645_PackNoDI(TxFrm , RxFrm , 6);
	return Len;
}

/**
 * @brief 处理写参数命令（AFN=0x14）。
 * @param ComPort 通信端口号。
 * @param RxFrm 指向接收到的DL/T645帧。
 * @return u16 响应帧的长度。
 */
u16 fnDl645B_Unpack14(u8 ComPort , sFrmDl645B_TypeDef *RxFrm)	//写参数
{
	eDL645B_ErrInfo_TypeDef 	err; // 错误码
	u16 Len; // 响应帧长度
	sFrmDl645B_TypeDef *TxFrm;
	
	TxFrm = (sFrmDl645B_TypeDef *)&ComPack[ComPort].TxBuf[DL645B_LEADERCODE_LEN];
	switch(RxFrm->UDat.DI3) // 根据数据标识符最高字节判断
	{
	case 0x04 : // 参数设置
		err = fnDl645_PutParaVar(RxFrm); // 调用参数设置处理函数
		break;
	default: // 其他不支持
		err = DL645B_ERRINFO_DATA;
		break;
	}
	// 打包响应帧（成功或失败都通过错误帧返回，ErrInfo为OK或具体错误码）
	Len = fnDl645_PackErr( TxFrm , RxFrm , err);
	return Len;
}

/**
 * @brief 处理写通信地址命令（AFN=0x15）。
 * @param ComPort 通信端口号。
 * @param RxFrm 指向接收到的DL/T645帧。
 * @return u16 响应帧的长度，0表示请求无效。
 */
u16 fnDl645B_Unpack15(u8 ComPort , sFrmDl645B_TypeDef *RxFrm)	//写通信地址
{
	u8 i;
	u16 Len;
	sFrmDl645B_TypeDef *TxFrm;
	TxFrm = (sFrmDl645B_TypeDef *)&ComPack[ComPort].TxBuf[DL645B_LEADERCODE_LEN];
	
	// 写通信地址命令要求地址域为全AA
	for(i = 0 ; i < 6 ; i++)
	{
		if(RxFrm->Addr[i] != 0xAA) return 0; // 地址不是全AA，无效请求
	}
	if(RxFrm->Len != 6) return 0; // 数据域长度应为6（新地址），无效请求
	if(fnDl645B_FramCheckBCD(&RxFrm->UDat.DI0, 6) == ERROR) return fnDl645_PackErr(TxFrm , RxFrm , DL645B_ERRINFO_DATA); // 检查新地址是否为BCD码
	
	// 写入新通信地址到文件系统
	fnDl645File_Write(Dl645FileId_HighPara , Dl645FileItemInfoOffAddr_HighPara_ComAddr , &RxFrm->UDat.DI0 , 6);
	// 打包正常响应帧（通过错误帧函数，错误码为OK）
	Len = fnDl645_PackErr(TxFrm , RxFrm , DL645B_ERRINFO_OK);
	return Len;
}

/**
 * @brief 解析接收到的DL/T645命令帧并生成响应。
 * @param ComPort 通信端口号。
 * @param RxFrm 指向接收到的DL/T645帧。
 * @return u16 响应帧的长度，0表示无响应。
 */
u16 fnDl645B_RxAnalyse(u8 ComPort , sFrmDl645B_TypeDef *RxFrm)
{
	u16 Len;
	
	if(RxFrm->Dir) return 0; // 如果是上行帧（Dir=1），不处理
	
	// 根据AFN调用相应的处理函数
	switch(RxFrm->AFN)
	{
	case 0x11:	Len = fnDl645B_Unpack11(ComPort , RxFrm); break; // 读数据
	case 0x13:	Len = fnDl645B_Unpack13(ComPort , RxFrm); break; // 读通信地址
	case 0x14:	Len = fnDl645B_Unpack14(ComPort , RxFrm); break; // 写参数
	case 0x15:	Len = fnDl645B_Unpack15(ComPort , RxFrm); break; // 写通信地址
	default: Len = 0 ; break; // 不支持的AFN
	}
	return Len; // 返回响应帧长度
}

/**
 * @brief DL/T645协议执行入口函数。
 * @param ComPort 通信端口号。
 * @param RxFrm 指向接收到的DL/T645帧。
 * @return u16 响应帧的长度，0表示无响应。
 */
u16 fnDl645B_Exec(u8 ComPort , sFrmDl645B_TypeDef *RxFrm)
{
	u16 Len;
	// 对接收到的数据域执行减0x33操作
	fnDl645B_Modify( (u8 *)&RxFrm->UDat , RxFrm->Len , 0);
	// 解析帧并生成响应
	Len = fnDl645B_RxAnalyse(ComPort , RxFrm);
	return Len; // 返回响应帧长度
}

